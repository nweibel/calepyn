{
  
    
        "post0": {
            "title": "Title",
            "content": "from mobilechelonian import Turtle . t = Turtle() t.speed(3) t.backward(100) for loop in range(5) : t.forward(200) t.right(144) . t = Turtle() t.speed(10) t.backward(100) for i in range(20) : t.forward(200) t.right(162) . t = Turtle() t.speed(10) t.backward(100) for i in range(10) : t.circle(30) t.right(36) .",
            "url": "https://nweibel.github.io/calepyns/2021/02/03/trac%C3%A9s-turtle.html",
            "relUrl": "/2021/02/03/trac%C3%A9s-turtle.html",
            "date": " • Feb 3, 2021"
        }
        
    
  
    
        ,"post1": {
            "title": "Sujet n°1",
            "content": "Voici une fonction mystere définie en pseudo-code. Elle possède un seul paramètre : nombre_binaire. . definition fonction mystere(nombre_binaire): Affecter à la variable resultat la valeur 0 Pour chaque caractere de nombre_binaire : #(parcouru de gauche à droite) - si caractere est égal à &#39;0&#39; : doubler resultat - sinon si caractere est égal à &#39;1&#39;: doubler resultat et ajouter 1 Renvoyer resultat . 1. Appliquer une fonction &#224; la main . 1.1 Déterminer &quot;à la main&quot; la valeur que renverrait la fonction mystere pour le paramètre : &#39;110&#39;. . 1.2 Même question pour les valeurs &#39;1000&#39;, &#39;1100&#39;, &#39;1111&#39;. . 1.3 Quelle interprétation peut-on faire ? Comment exprimer en une phrase ce que réalise cette fonction ? (on demande une simple conjecture, sans démonstration). . 2. Compl&#233;ter une fonction . 2.1 La fonction mystere a été ci-dessous écrite en Python, mais le code est incomplet. Compléter la fonction en remplaçant chaque &quot;#à compléter&quot; par l&#39;expression appropriée. . def mystere(nombre_binaire): resultat = #à compléter for caractere in nombre_binaire: if #à compléter : resultat = #à compléter elif #à compléter : resultat = #à compléter return #à compléter . 2.2 Tester la fonction complétée en l&#39;appelant pour les valeurs de nombre_binaire de la question 1.2. Comparer les résultats obtenus à la main et les résultats obtenus à l&#39;aide de la fonction en python. . écriture binaire exécution à la main exécution de la fonction en python Comparaison des résultats . &#39;110&#39; | | | | . &#39;1000&#39; | | | | . &#39;1100&#39; | | | | . &#39;1111&#39; | | | | . 3. Tester une fonction . On peut réaliser des tests sur une fonction à l&#39;aide de l&#39;instruction assert, qui ne renvoie rien si tout est correct mais qui affiche un message d&#39;erreur dans le cas contraire. Elle vérifie, pour une valeur choisie du paramètre, que la fonction renvoie bien la valeur attendue. . assert(mystere(&#39;10011111&#39;) == 159), &quot;la fonction mystere contient une erreur&quot; . 3.1 Exécuter la cellule précédente : aucun affichage ne doit se produire. Dans le cas contraire, modifier la fonction mystere. . 3.2 Choisir un nombre binaire s&#39;écrivant sur un octet et écrire une ligne de test comportant un assert en s&#39;inspirant de l&#39;instruction ci-dessus. . 3.3 Quelle fonction native en python renvoie le même résultat que la fonction mystère (complétée) ? . 4 Une machine particuli&#232;re . Une &quot;machine à calculer&quot; un peu particulière comporte un écran permettant d&#39;afficher 10 chiffres et un clavier de 3 touches dont les fonctions sont : . mettre la valeur affichée à 0 | doubler la valeur affichée | doubler la valeur affichée et ajouter 1. | . 4.1 Peut-on afficher 159 sur cette machine ? Si oui, comment ? Sur combien de touches faut-il appuyer ? . 4.2 Quel est le plus petit entier positif que l&#39;on ne peut pas afficher sur l&#39;écran de cette machine ? .",
            "url": "https://nweibel.github.io/calepyns/jupyter/binaire/dm/2020/08/31/NSI-2020-DM1.html",
            "relUrl": "/jupyter/binaire/dm/2020/08/31/NSI-2020-DM1.html",
            "date": " • Aug 31, 2020"
        }
        
    
  
    
        ,"post2": {
            "title": "Turtle et notebook Jupyter",
            "content": "Le module mobilechelonian permet d&#39;utiliser une grande part des instructions Turtle dans un notebook Jupyter. . Documentation : https://pypi.org/project/mobilechelonian/ . Installation du module : pip install mobilechelonian . from mobilechelonian import Turtle . t = Turtle() t.speed(3) for loop in range(6) : t.forward(100) t.left(60) . def hexagone(taille): for loop in range(6) : t.forward(taille) t.left(60) t = Turtle() t.speed(5) for i in range(3): t.setbearing(120*i) hexagone(80) . t = Turtle() t.speed(5) colours=[&quot;red&quot;,&quot;blue&quot;,&quot;yellow&quot;, &quot;green&quot;, &quot;white&quot;, &quot;cyan&quot;, &quot;orange&quot;, &quot;pink&quot;, &quot;lightgreen&quot;] t.penup() t.left(90) t.forward(200) t.right(90) t.pendown() for i in range (18): t.pencolor(colours[i%9]) t.right(20) t.forward(50) t.right(180) t.home() . M&#233;thodes disponibles . forward(num) . Fait avancer la tortue de num unités. . Exemple:t.forward(100) . backward(num) . Fait reculer la tortue de num unités. . Exemple:t.backward(100) . left(num) . Fait tourner la tortue de num degrés vers la gauche. . Exemple:t.left(90) . right(num) . Fait tourner la tortue de num degrés vers la droite. . Exemple:t.right(90) . circle(rayon, angle=360) . Trace un cercle ou un arc de cercle À partir de sa position actuelle, la tortue dessinera une série de lignes courtes, tournant légèrement entre 2 lignes. Si le rayon est positif, elle tournera sur sa gauche et si le rayon est négatif elle tournera sur sa droite. . Exemple:t.circle(50) . home() . Déplace la tortue à sa position d&#39;origine. . Exemple:t.home() . pencolor(color) . Change la couleur du stylo, noire par défaut. Couleurs disponibles :&quot;red&quot;,&quot;blue&quot;,&quot;yellow&quot;,&quot;brown&quot;,&quot;black&quot;,&quot;green&quot;,&quot;purple&quot;, &quot;white&quot;, &quot;cyan&quot;, &quot;orange&quot;, &quot;grey&quot;, &quot;pink&quot;, &quot;lightgreen&quot;, &quot;lightblue&quot; . Exemple: t.pencolor(&quot;red&quot;) . pendown() . Baisse le stylo. Au départ, le stylo est abaissé. . Exemple:t.pendown() . penup() . Relève le stylo. . Exemple:t.penup() . setbearing(angle) . Change la direction de la tortue. . Exemple:t.setbearing(180) . setposition(x, y, bearing=None) . Change la position de la tortue. . Exemple:t.setposition(100, 100) . speed(speed) . Modifie la vitesse de la tortue (entre 1 et 10). . Exemple:t.speed(10) . Exemple de trac&#233; r&#233;cursif . t = Turtle() t.speed(10) def koch(n,longueur): if n==0: t.forward(longueur) else: koch(n-1,longueur/3) t.left(60) koch(n-1,longueur/3) t.right(120) koch(n-1,longueur/3) t.left(60) koch(n-1,longueur/3) t.penup() t.left(90) t.forward(150) t.right(180) t.pendown() koch(4,300) .",
            "url": "https://nweibel.github.io/calepyns/jupyter/tortue/2020/08/30/Turtle.html",
            "relUrl": "/jupyter/tortue/2020/08/30/Turtle.html",
            "date": " • Aug 30, 2020"
        }
        
    
  
    
        ,"post3": {
            "title": "Une histoire de tiroirs",
            "content": "Voici quelques extraits d&#39;un article de Jean-Paul Delahaye, publié dans Pour la science 483 en janvier 2018 : . Si l’on se donne 10 entiers quelconques composés de deux chiffres, il existe parmi eux deux sous-ensembles disjoints de nombres ayant la même somme. Par exemple, si l’on se donne {23, 35, 44, 61, 68, 70, 71, 82, 83, 95}, on trouvera que {23, 35, 95} donne la même somme que {71, 82} :23 + 35 + 95 = 153 = 71 + 82 . Démonstration :Les sous-ensembles possibles de notre ensemble de 10 entiers sont aunombre de $2^{10}$ = 1 024, car pour constituer un tel sous-ensemble, on opère 10 fois de suite le choix binaire : prendre le nombre ou ne pas le prendre. Quels nombres peut-on atteindre en faisant la somme des nombres de nos sous-ensembles ? Un sous-ensemble comporte de 0 à 10 nombres compris entre 10 et 99 ; la somme est donc comprise entre 0 et 10 fois 99, donc entre 0 et 990. En numérotant 991 tiroirs de 0 à 990, et en plaçant chaque sous-ensemble possible dans le tiroir dont le numéro est la somme de ses éléments, on trouve d’après le principe des tiroirs deux sous-ensembles ayant la même somme. Le problème n’est cependant pas vraiment résolu, car on nous demande de trouver des sous-ensembles disjoints ayant la même somme, et rien ne nous permet d’affirmer que les deux sous-ensembles trouvés à l’instant le sont. Ce n’est pas très grave :si les sous-ensembles ontdes éléments en commun, on les enlève. Les deux sous-ensembles alors obtenus ont encore la même somme, car on a enlevé les mêmes éléments, et cette fois ce sont deux sous-ensembles disjoints. . Ce résultat assure l&#39;existence d&#39;au moins une solution. L&#39;objectif est ici d&#39;exhiber toutes les solutions pour un ensemble de 10 entiers aléatoires entre 10 et 99. . G&#233;n&#233;rer un tableau de 10 entiers distincts . Les dix entiers sont compris entre 10 et 99 | Ils sont distincts | . from random import randint def genere_dix_entiers(): entiers = [] while len(entiers) &lt; 10: nouvel_entier = randint(10,99) if nouvel_entier not in entiers : entiers.append(nouvel_entier) else: pass return(entiers) . G&#233;n&#233;rer toutes les parties d&#39;un ensemble . Trois méthodes sont proposées : une seule suffit, mais cela permet de choisir celle qui convient le mieux au contexte. . M&#233;thode 1 : construction par ajout d&#39;&#233;lements successifs . def partiesliste1(liste): &quot;&quot;&quot; genere toutes les parties de l&#39;ensemble des éléments de liste &gt;&gt;&gt; partiesliste1([1,2,3]) [[1, 2, 3], [2, 3], [1, 3], [3], [1, 2], [2], [1], []] &quot;&quot;&quot; parties = [[]] while liste: premier = liste[0] liste = liste[1:] construction = [x + [premier] for x in parties] + parties parties = construction return parties . M&#233;thode 2 : construction &#224; l&#39;aide du binaire . def partiesliste2(liste): &quot;&quot;&quot; genere toutes les parties de l&#39;ensemble des éléments de liste pour une valeur du compteur i, s&#39;il y a un &#39;1&#39; en j-ème position du compteur en binaire, alors on ajoute le j-ème élément dans la liste correspondant à ce compteur. &gt;&gt;&gt; partiesliste2([1,2,3]) [[], [1], [2], [1, 2], [3], [1, 3], [2, 3], [1, 2, 3]] &quot;&quot;&quot; parties = [] for i in range(2**len(liste)): nouveau = [] for j in range(len(liste)): if (i &gt;&gt; j) &amp; 1 == 1: # si l&#39;écriture binaire de i comporte un 1 en j-eme position nouveau.append(liste[j]) parties.append(nouveau) return parties . M&#233;thode 3 : utilisation du module itertools . import itertools def partiesliste3(liste): &quot;&quot;&quot; genere toutes les parties de l&#39;ensemble des éléments de liste, de taille croissante &gt;&gt;&gt; partiesliste3([1,2,3]) [[], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]] &quot;&quot;&quot; parties = [] for i in range(0, len(liste)+1): for partie in itertools.combinations(liste, i): parties.append(list(partie)) return parties . Calculer la somme des &#233;l&#233;ments de chaque partie . def calcule_sommes(liste_parties): sommes = {} for partie in liste_parties: somme = sum(partie) if somme not in sommes : sommes[somme] = [partie] else : sommes[somme].append(partie) return sommes . Rechercher les &#233;l&#233;ments d&#39;un dictionnaire dont la valeur a une longueur d&#39;au moins 2. . def recherche_sommes_communes(dico): sommes_communes = {} for cle in dico: if len(dico[cle]) &gt; 1 : sommes_communes[cle] = dico[cle] return sommes_communes . Supprimer les listes non disjointes . def nettoyage(dico): &quot;&quot;&quot; crée un dictionnaire contenant les clés de dico, lorsqu&#39;au moins deux listes disjointes ont cette valeur pour somme Les valeurs associées à la clé sont les paires de deux ensembles disjoints dont la somme est la clé &quot;&quot;&quot; sommes_nettoyees={} for cle in dico: tableau = (dico[cle]) for i in range(len(tableau)): for j in range(i+1,len(tableau)): if set(tableau[i]).isdisjoint(set(tableau[j])): if cle not in sommes_nettoyees : sommes_nettoyees[cle] = [[set(tableau[i]), set(tableau[j])]] else : sommes_nettoyees[cle].append([set(tableau[i]), set(tableau[j])]) return sommes_nettoyees . Voir les solutions . mes_dix_nombres = genere_dix_entiers() mes_dix_nombres . [44, 79, 15, 74, 72, 18, 54, 19, 14, 97] . mes_sommes_communes = recherche_sommes_communes(calcule_sommes(partiesliste2(mes_dix_nombres))) . solutions = nettoyage(mes_sommes_communes) print(&quot;Liste ordonnée des sommes que l&#39;on peut obtenir à partir d&#39;au moins deux sous-ensembles distincts de la liste &quot;, mes_dix_nombres,&quot; : n&quot;, sorted([cle for cle in solutions])) solutions . Liste ordonnée des sommes que l&#39;on peut obtenir à partir d&#39;au moins deux sous-ensembles distincts de la liste [44, 79, 15, 74, 72, 18, 54, 19, 14, 97] : [33, 72, 73, 87, 88, 91, 92, 93, 97, 98, 106, 111, 112, 116, 123, 126, 130, 133, 141, 142, 146, 148, 151, 153, 155, 159, 160, 165, 169, 170, 171, 176, 184, 185, 187, 189, 190, 191, 194, 205, 206, 207, 209, 216, 221, 234, 243] . {123: [[{44, 79}, {14, 18, 19, 72}]], 153: [[{74, 79}, {18, 19, 44, 72}]], 133: [[{15, 44, 74}, {54, 79}]], 72: [[{72}, {18, 54}]], 116: [[{44, 72}, {18, 19, 79}], [{44, 72}, {19, 97}], [{18, 44, 54}, {19, 97}]], 151: [[{72, 79}, {15, 18, 44, 74}], [{72, 79}, {14, 19, 44, 74}], [{72, 79}, {54, 97}], [{15, 18, 44, 74}, {54, 97}], [{18, 54, 79}, {14, 19, 44, 74}], [{14, 19, 44, 74}, {54, 97}]], 87: [[{15, 72}, {14, 19, 54}]], 146: [[{72, 74}, {14, 15, 19, 44, 54}]], 190: [[{44, 72, 74}, {14, 79, 97}], [{18, 44, 54, 74}, {14, 79, 97}]], 205: [[{54, 72, 79}, {15, 19, 74, 97}]], 97: [[{18, 79}, {97}]], 141: [[{18, 44, 79}, {15, 54, 72}], [{15, 54, 72}, {44, 97}]], 33: [[{15, 18}, {14, 19}]], 112: [[{15, 18, 79}, {14, 44, 54}], [{14, 44, 54}, {15, 97}], [{14, 19, 79}, {15, 97}]], 92: [[{18, 74}, {14, 15, 19, 44}]], 171: [[{14, 15, 19, 44, 79}, {74, 97}]], 169: [[{14, 18, 19, 44, 74}, {72, 97}]], 184: [[{15, 18, 72, 79}, {14, 19, 54, 97}], [{14, 19, 72, 79}, {15, 18, 54, 97}], [{14, 18, 19, 54, 79}, {15, 72, 97}]], 243: [[{18, 72, 74, 79}, {14, 15, 19, 44, 54, 97}], [{14, 15, 19, 44, 72, 79}, {18, 54, 74, 97}], [{14, 15, 18, 19, 44, 54, 79}, {72, 74, 97}]], 98: [[{44, 54}, {19, 79}]], 148: [[{15, 54, 79}, {14, 18, 44, 72}], [{15, 54, 79}, {14, 18, 19, 97}]], 207: [[{54, 74, 79}, {14, 15, 18, 19, 44, 97}]], 187: [[{15, 44, 54, 74}, {18, 72, 97}], [{15, 19, 74, 79}, {18, 72, 97}]], 126: [[{54, 72}, {15, 18, 19, 74}], [{54, 72}, {14, 15, 18, 79}], [{54, 72}, {14, 15, 97}]], 170: [[{19, 72, 79}, {14, 15, 44, 97}], [{18, 19, 54, 79}, {14, 15, 44, 97}], [{14, 15, 18, 44, 79}, {19, 54, 97}]], 185: [[{15, 44, 54, 72}, {14, 18, 74, 79}], [{15, 44, 54, 72}, {14, 74, 97}], [{15, 19, 72, 79}, {14, 74, 97}], [{15, 18, 19, 54, 79}, {14, 74, 97}], [{14, 18, 74, 79}, {15, 19, 54, 97}]], 159: [[{14, 19, 54, 72}, {18, 44, 97}]], 142: [[{19, 44, 79}, {14, 54, 74}]], 93: [[{19, 74}, {14, 79}]], 216: [[{19, 44, 74, 79}, {14, 15, 18, 72, 97}]], 91: [[{19, 72}, {14, 15, 18, 44}]], 106: [[{15, 19, 72}, {14, 18, 74}]], 165: [[{19, 72, 74}, {14, 18, 54, 79}], [{19, 72, 74}, {14, 54, 97}], [{18, 19, 54, 74}, {14, 72, 79}]], 209: [[{19, 44, 72, 74}, {15, 18, 79, 97}]], 160: [[{18, 19, 44, 79}, {14, 72, 74}], [{14, 72, 74}, {19, 44, 97}], [{14, 18, 54, 74}, {19, 44, 97}]], 111: [[{18, 19, 74}, {14, 97}]], 155: [[{18, 19, 44, 74}, {14, 15, 54, 72}]], 234: [[{15, 19, 54, 72, 74}, {14, 44, 79, 97}], [{14, 15, 54, 72, 79}, {19, 44, 74, 97}]], 73: [[{19, 54}, {14, 15, 44}]], 88: [[{15, 19, 54}, {14, 74}]], 191: [[{19, 44, 54, 74}, {15, 79, 97}]], 206: [[{14, 15, 44, 54, 79}, {18, 19, 72, 97}]], 189: [[{19, 44, 54, 72}, {18, 74, 97}]], 130: [[{14, 44, 72}, {15, 18, 97}]], 221: [[{14, 54, 74, 79}, {15, 18, 19, 72, 97}]], 194: [[{14, 15, 19, 72, 74}, {18, 79, 97}]], 176: [[{14, 15, 19, 54, 74}, {79, 97}]]} . compteur = 0 for cle in solutions: compteur = compteur + len(solutions[cle]) compteur . 77 .",
            "url": "https://nweibel.github.io/calepyns/jupyter/binaire/combinaisons/2020/08/18/tiroirs.html",
            "relUrl": "/jupyter/binaire/combinaisons/2020/08/18/tiroirs.html",
            "date": " • Aug 18, 2020"
        }
        
    
  
    
        ,"post4": {
            "title": "Le jeu de Nim par apprentissage",
            "content": "Les R&#232;gles du jeu . Nombre de joueurs : 2 . Principe : on dispose de 8 allumettes. Chaque joueur peut prendre 1, 2 ou 3 allumettes, à tour de rôle. Celui qui prend la dernière allumette gagne la partie. . . Remarque : . Le jeu de Nim est cité comme exemple d&#39;activité dans le thème E des programmes de mathématiques du cycle 4. . On peut par exemple programmer sur Scratch un jeu opposant un adversaire humain à &quot;l&#39;ordinateur&quot; : ici avec 12 &quot;bougies&quot;. . . Dans ce contexte, on écrit un algorithme qui décide ce que va jouer la machine. L&#39;agorithme attendu peut-être &quot;naïf&quot; : ou expert (pour une machine qui ne commence pas la partie) : . Différentes versions sont disponibles dans ce studio Scratch : https://scratch.mit.edu/studios/28731231/ . Objectif de la version &quot;par apprentissage&quot; : . L&#39;un des joueurs est un humain, l&#39;autre joueur est &quot;une machine&quot;. Celle-ci doit apprendre à jouer contre son adversaire au fur et à mesure des parties jouées. . Cette activité présente ainsi une forme simple d&#39;apprentissage, à l&#39;issue duquel la machine aboutit à la stratégie gagnante à ce jeu. . Version 1 : sans ordinateur . Matériel : . 8 allumettes | 8 gobelets numérotés de 1 à 8 | 21 jetons : 8 jetons portant le n°1, 7 jetons portant le n°2 et 6 jetons portant le n°3. | . Chaque gobelet contient 3 jetons numérotés 1, 2, et 3, sauf le gobelet 1 qui ne contient qu&#39;un jeton numéroté 1, et le gobelet 2 qui ne contient que deux jetons numérotés 1 et 2. . . Déroulement : . Commencer une partie en laissant l&#39;humain jouer en premier. L&#39;humain joue comme il veut... . Lorsque c&#39;est à la machine de jouer, elle : . compte le nombre d&#39;allumettes restant et prend le gobelet correspondant, | pioche au hasard un jeton dans le gobelet, le pose sur la table juste devant ce gobelet, et pioche le nombre d&#39;allumettes indiqué par le jeton (1, 2 ou 3). | . En fin de partie, quand il n&#39;y a plus d&#39;allumettes, . soit la machine a gagné, et dans ce cas elle remet chaque jeton dans le gobelet où elle l&#39;a pioché, | soit elle a perdu et dans ce cas elle remet tous les jetons piochés sauf le dernier -- ce choix a permis à l&#39;humain de gagner -- et elle le met de côté. | . Au cours des parties successives, il peut arriver qu&#39;un gobelet soit vide. Dans ce cas on retourne le gobelet à l&#39;envers, et à partir de ce moment-là, si l&#39;adversaire laisse un nombre d&#39;allumettes pour lequel le gobelet est vide, la machine abandonne la partie, considère qu&#39;elle a perdu et remet tous les jetons piochés dans leur gobelet sauf le dernier. . Constats : . La machine va souvent perdre au début, mais au fil des parties elle va s&#39;améliorer et finir par suivre une stratégie qui la fera gagner à tous les coups. . Version 2 : programme Python . %matplotlib notebook from random import choice, randint import matplotlib.pyplot as plt . Jeu de la machine : . Les coups possibles au départ pour la machine sont de prendre 1, 2 ou 3 allumettes, s&#39;il en reste au moins 3. . S&#39;il n&#39;en reste que 2, elle peut en prendre 1 ou 2, et s&#39;il n&#39;en reste qu&#39;une, la machine la prend. . On modélise la situation par un tableau comportant la liste des coups possibles dans chaque cas : . coups_possibles = [[1], [1, 2]] + [[1,2,3] for i in range(NB_ALLUMETTES - 2)] où NB_ALLUMETTES est le nombre initial d&#39;allumettes, ici 8. . Lorsqu&#39;elle doit jouer, la machine choisit au hasard l&#39;un des coups possibles pour le nombre d&#39;allumettes restant. . Si aucun coup n&#39;est disponible, elle abandonne la partie qu&#39;elle considère comme perdue. . En fin de partie, si la machine a perdu, elle supprime de la liste des coups possibles le dernier coup réalisé. . def jouer_machine(nb_allumettes): &#39;&#39;&#39; - prend en paramètre le nombre d&#39;allumettes restant à jouer - renvoie le nombre d&#39;allumettes prises lors du coup joué par la machine et un booléen indiquant si ce coup a conduit à la perte de la partie pour la machine &#39;&#39;&#39; perdu = False if coups_possibles[nb_allumettes - 1] != []: coup_joue = choice(coups_possibles[nb_allumettes - 1]) else : perdu = True coup_joue = 0 return (coup_joue, perdu) . Jeu de l&#39;adversaire: . L&#39;adversaire adopte une stratégie élémentaire : . S&#39;il reste au plus 3 allumettes, il les prend toutes -- et la partie est perdue pour la machine ; | sinon, il choisit aléatoirement, entre 1 et 3, le nombre d&#39;allumettes à prendre. | . def jouer_adversaire(nb_allumettes): &#39;&#39;&#39; - prend en paramètre le nombre d&#39;allumettes restant à jouer - renvoie le nombre d&#39;allumettes prises lors du coup joué par l&#39;adversaire et un booléen indiquant si ce coup a conduit à la perte de la partie pour la machine &#39;&#39;&#39; perdu = False if nb_allumettes &lt; 4: coup_joue = nb_allumettes perdu = True else : coup_joue = randint(1, 3) return (coup_joue, perdu) . D&#233;roulement du jeu . NB_ALLUMETTES = 8 . def jouer_partie(n): &#39;&#39;&#39; simule le déroulement de n parties successives, en faisant toujours commencer l&#39;adversaire de la machine et renvoie la liste des numéros des parties perdues &#39;&#39;&#39; parties_perdues = [] for i in range(n): perdu = False # perdu prend la valeur True lorsque la machine perd la partie allumettes = [NB_ALLUMETTES] # contient les valeurs successives au # cours d&#39;une partie du nombre d&#39;allumettes restantes while not perdu and allumettes[-1] &gt; 0 : #l&#39;adversaire joue nb_allumettes, perdu = jouer_adversaire(allumettes[-1]) allumettes.append(allumettes[-1] - nb_allumettes) if perdu : # le dernier coup de la machine a permis à l&#39;adversaire de # gagner : on supprime le coup correspondant de la # liste des coups possibles coups_possibles[allumettes[-3] - 1].remove(allumettes[-3] - allumettes[-2]) else : # la machine joue nb_allumettes, perdu = jouer_machine(allumettes[-1]) allumettes.append(allumettes[-1] - nb_allumettes) if perdu : #le précédent coup de la machine a conduit à sa défaite : # on supprime le coup correspondant de la liste des coups possibles coups_possibles[allumettes[-4] - 1].remove(allumettes[-4] - allumettes[-3]) if perdu : parties_perdues.append(i) return (parties_perdues) . Exemples de situations possibles au bout d&#39;une partie . allumettes = [8, 7, 4, 2, 1, 0] on supprime le jeton 1 du gobelet 2 coups_possibles = [[1], [2], [1, 2, 3], [1, 2, 3], [1, 2, 3], [1, 2, 3], [1, 2, 3], [1, 2, 3]] . | allumettes = [8, 6, 5, 3, 2, 0] on supprime le jeton 1 du gobelet 3 coups_possibles = [[1], [1, 2], [2, 3], [1, 2, 3], [1, 2, 3], [1, 2, 3], [1, 2, 3], [1, 2, 3]] . | allumettes = [8, 7, 5, 4, 1, 0] on supprime le jeton 3 du gobelet 4 coups_possibles = [[1], [1, 2], [1, 2, 3], [1, 2], [1, 2, 3], [1, 2, 3], [1, 2, 3], [1, 2, 3]] . | allumettes = [8, 5, 2, 0] on supprime le jeton 3 du gobelet 5 coups_possibles = [[1], [1, 2], [1, 2, 3], [1, 2, 3], [1, 2], [1, 2, 3], [1, 2, 3], [1, 2, 3]] . | allumettes = [8, 6, 3, 0] on supprime le jeton 3 du gobelet 6 coups_possibles = [[1], [1, 2], [1, 2, 3], [1, 2, 3], [1, 2, 3], [1, 2], [1, 2, 3], [1, 2, 3]] . | allumettes = [8, 6, 5, 3, 0] la machine a gagné ! coups_possibles = [[1], [1, 2], [1, 2, 3], [1, 2, 3], [1, 2, 3], [1, 2, 3], [1, 2, 3], [1, 2, 3]] . | . Exemples de situations n&#233;cessitant plus d&#39;une partie . allumettes = [8, 6, 5, 4, 4] avec coups_possibles[4] = []: on supprime le jeton 1 du gobelet 6 . | allumettes = [8, 7, 6, 4, 4] avec coups_possibles[4] = []: on supprime le jeton 1 du gobelet 7 . | . Simulation de parties jou&#233;es, affichage des rangs des parties perdues . coups_possibles = [[1], [1, 2]] + [[1,2,3] for i in range(NB_ALLUMETTES - 2)] parties_perdues = jouer_partie(100) print(&quot;parties perdues : &quot;, len(parties_perdues), parties_perdues) . parties perdues : 12 [0, 1, 3, 4, 7, 8, 12, 46, 49, 55, 57, 66] . print(coups_possibles) . [[1], [2], [3], [], [1], [2], [3], [1, 2, 3]] . Constat . La machine a appris à gagner à ce jeu : elle ignorait comment procéder au début et perdait fréquemment. Elle a appris de chaque partie perdue et obtient une stratégie qui s&#39;améliore au fil des parties, voire optimale si on la laisse jouer suffisamment de parties. Les parties jouées, réelles (version 1) ou simulées (version 2), sont les données sur lesquelles s’appuie son apprentissage. . Cette situation illustre le fait que la machine peut apprendre une stratégie que l’humain ne connait pas au départ, et dont la découverte aurait demandé à l’humain de faire preuve d’intelligence. Si l&#39;on retient de l&#39;intelligence artificielle la définition de Marvin Minsky, . L’intelligence artificielle est la science qui permet de faire réaliser à des machines des tâches qui nécessiteraient de l’intelligence si elles étaient réalisées par des humains. . peut-on considérer que la machine a fait preuve d&#39;intelligence artificielle ? . Simulation de parties jou&#233;es, affichage des rangs des derni&#232;res parties perdues . def simulation(nb_repetitions, nb_parties): global coups_possibles dernieres_perdues = [] for i in range(nb_repetitions): coups_possibles = [[1], [1, 2]] + [[1,2,3] for i in range(NB_ALLUMETTES - 2)] parties_perdues = jouer_partie(nb_parties) if len(parties_perdues) == 12: dernieres_perdues.append(parties_perdues[-1]) return dernieres_perdues . print(simulation(25, 200)) . [45, 59, 52, 32, 87, 26, 50, 30, 96, 29, 98, 42, 147, 39, 35, 69, 53, 34, 58, 32, 79, 78, 56, 59, 82] . def representation_graphique(n): plt.clf() dernieres_perdues = simulation(n, 300) plt.scatter(list(range(n)), dernieres_perdues, s = 8, c = &#39;r&#39;) moyenne = sum(dernieres_perdues)/len(dernieres_perdues) plt.axhline(moyenne) plt.title(&#39;Rang de la dernière partie perdue&#39;) plt.xlabel(&quot;numéro de l&#39;échantillon&quot;) plt.ylabel(&#39;rang de la dernière partie perdue&#39;) plt.show() . representation_graphique(200) . D&#39;après les simulations sur 200 échantillons, en moyenne, la machine devient experte au bout de 60 parties. . Si l&#39;on modifie la stratégie de jeu de l&#39;adversaire, cela influence-t-il ce paramètre ? . Influence de la strat&#233;gie de l&#39;adversaire . #L&#39;adversaire adopte une stratégie experte def jouer_adversaire(nb_allumettes): &#39;&#39;&#39; - prend en paramètre le nombre d&#39;allumettes restant à jouer - renvoie le nombre d&#39;allumettes prises lors du coup joué par l&#39;adversaire et un booléen indiquant si ce coup a conduit à la perte de la partie pour la machine &#39;&#39;&#39; perdu = False if nb_allumettes &lt; 4: coup_joue = nb_allumettes perdu = True elif nb_allumettes %4 != 0: coup_joue = nb_allumettes % 4 else : coup_joue = randint(1, 3) return (coup_joue, perdu) . representation_graphique(200) . Avec une stratégie experte, l&#39;adversaire impose à la machine de perdre dès que possible. En moyenne sur 200 réalisations, le rang de la dernière partie perdue est d&#39;environ 25. . Sources : . Quand une machine apprend à jouer au jeu de Nim (Marie Duflot), (CC BY SA) | . Pour aller plus loin : . Une machine en boites d&#39;alumettes qui apprend à jouer au morpion, Lisa Rougetet | Un jeu pour comprendre l&#39;apprentissage automatique, Florent Madelaine &amp; Malika More | La machine qui apprend à (bien) jouer toute seule, Eric Duchêne et Aline Parreau | .",
            "url": "https://nweibel.github.io/calepyns/jupyter/jeu/2020/07/31/jeu_de_nim.html",
            "relUrl": "/jupyter/jeu/2020/07/31/jeu_de_nim.html",
            "date": " • Jul 31, 2020"
        }
        
    
  
    
        ,"post5": {
            "title": "Le jeu de Nim par apprentissage",
            "content": "Les R&#232;gles du jeu . Nombre de joueurs : 2 . Principe : on dispose de 8 allumettes. Chaque joueur peut prendre 1, 2 ou 3 allumettes, à tour de rôle. Celui qui prend la dernière allumette gagne la partie. . Remarque : . Le jeu de Nim est cité comme exemple d&#39;activité dans le thème E des programmes de mathématiques du cycle 4. . On peut par exemple programmer sur Scratch un jeu opposant un adversaire humain à &quot;l&#39;ordinateur&quot; : ici avec 12 &quot;bougies&quot;. . . Dans ce contexte, on écrit un algorithme qui décide ce que va jouer la machine. L&#39;agorithme attendu peut-être &quot;naïf&quot; : . ou expert (pour une machine qui ne commence pas la partie) : . Différentes versions sont disponibles dans ce studio Scratch : https://scratch.mit.edu/studios/28731231/ . Objectif de la version &quot;par apprentissage&quot; : . L&#39;un des joueurs est un humain, l&#39;autre joueur est &quot;une machine&quot;. Celle-ci doit apprendre à jouer contre son adversaire au fur et à mesure des parties jouées. . Cette activité présente ainsi une forme simple d&#39;apprentissage, à l&#39;issue duquel la machine aboutit à la stratégie gagnante à ce jeu. . Version 1 : sans ordinateur . Matériel : . 8 allumettes | 8 gobelets numérotés de 1 à 8 | 21 jetons : 8 jetons portant le n°1, 7 jetons portant le n°2 et 6 jetons portant le n°3. | . Chaque gobelet contient 3 jetons numérotés 1, 2, et 3, sauf le gobelet 1 qui ne contient qu&#39;un jeton numéroté 1, et le gobelet 2 qui ne contient que deux jetons numérotés 1 et 2. . . Déroulement : . Commencer une partie en laissant l&#39;humain jouer en premier. L&#39;humain joue comme il veut... . Lorsque c&#39;est à la machine de jouer, elle : . compte le nombre d&#39;allumettes restant et prend le gobelet correspondant, | pioche au hasard un jeton dans le gobelet, le pose sur la table juste devant ce gobelet, et pioche le nombre d&#39;allumettes indiqué par le jeton (1, 2 ou 3). | . En fin de partie, quand il n&#39;y a plus d&#39;allumettes, . soit la machine a gagné, et dans ce cas elle remet chaque jeton dans le gobelet où elle l&#39;a pioché, | soit elle a perdu et dans ce cas elle remet tous les jetons piochés sauf le dernier -- ce choix a permis à l&#39;humain de gagner -- et elle le met de côté. | . Au cours des parties successives, il peut arriver qu&#39;un gobelet soit vide. Dans ce cas on retourne le gobelet à l&#39;envers, et à partir de ce moment-là, si l&#39;adversaire laisse un nombre d&#39;allumettes pour lequel le gobelet est vide, la machine abandonne la partie, considère qu&#39;elle a perdu et remet tous les jetons piochés dans leur gobelet sauf le dernier. . Constats : . La machine va souvent perdre au début, mais au fil des parties elle va s&#39;améliorer et finir par suivre une stratégie qui la fera gagner à tous les coups. . Version 2 : programme Python . %matplotlib notebook from random import choice, randint import matplotlib.pyplot as plt . Jeu de la machine : . Les coups possibles au départ pour la machine sont de prendre 1, 2 ou 3 allumettes, s&#39;il en reste au moins 3. . S&#39;il n&#39;en reste que 2, elle peut en prendre 1 ou 2, et s&#39;il n&#39;en reste qu&#39;une, la machine la prend. . On modélise la situation par une liste comportant la liste des coups possibles dans chaque cas : . coups_possibles = [[1], [1, 2]] + [[1,2,3] for i in range(NB_ALLUMETTES - 2)] où NB_ALLUMETTES est le nombre initial d&#39;allumettes, ici 8. . Lorsqu&#39;elle doit jouer, la machine choisit au hasard l&#39;un des coups possibles pour le nombre d&#39;allumettes restant. . Si aucun coup n&#39;est disponible, elle abandonne la partie qu&#39;elle considère comme perdue. . En fin de partie, si la machine a perdu, elle supprime de la liste des coups possibles le dernier coup réalisé. . def jouer_machine(nb_allumettes): &#39;&#39;&#39; - prend en paramètre le nombre d&#39;allumettes restant à jouer - renvoie le nombre d&#39;allumettes prises lors du coup joué par la machine et un booléen indiquant si ce coup a conduit à la perte de la partie pour la machine &#39;&#39;&#39; perdu = False if coups_possibles[nb_allumettes - 1] != []: coup_joue = choice(coups_possibles[nb_allumettes - 1]) else : perdu = True coup_joue = 0 return (coup_joue, perdu) . Jeu de l&#39;adversaire: . L&#39;adversaire adopte une stratégie élémentaire : . S&#39;il reste au plus 3 allumettes, il les prend toutes -- et la partie est perdue pour la machine ; | sinon, il choisit aléatoirement, entre 1 et 3, le nombre d&#39;allumettes à prendre. | . def jouer_adversaire(nb_allumettes): &#39;&#39;&#39; - prend en paramètre le nombre d&#39;allumettes restant à jouer - renvoie le nombre d&#39;allumettes prises lors du coup joué par l&#39;adversaire et un booléen indiquant si ce coup a conduit à la perte de la partie pour la machine &#39;&#39;&#39; perdu = False if nb_allumettes &lt; 4: coup_joue = nb_allumettes perdu = True else : coup_joue = randint(1, 3) return (coup_joue, perdu) . D&#233;roulement du jeu . NB_ALLUMETTES = 8 . def jouer_partie(n): &#39;&#39;&#39; simule le déroulement de n parties successives, en faisant toujours commencer l&#39;adversaire de la machine et renvoie la liste des numéros des parties perdues &#39;&#39;&#39; parties_perdues = [] for i in range(n): perdu = False # perdu prend la valeur True lorsque la machine perd la partie allumettes = [NB_ALLUMETTES] # contient les valeurs successives au # cours d&#39;une partie du nombre d&#39;allumettes restantes while not perdu and allumettes[-1] &gt; 0 : #l&#39;adversaire joue nb_allumettes, perdu = jouer_adversaire(allumettes[-1]) allumettes.append(allumettes[-1] - nb_allumettes) if perdu : # le dernier coup de la machine a permis à l&#39;adversaire de # gagner : on supprime le coup correspondant de la # liste des coups possibles coups_possibles[allumettes[-3] - 1].remove(allumettes[-3] - allumettes[-2]) else : # la machine joue nb_allumettes, perdu = jouer_machine(allumettes[-1]) allumettes.append(allumettes[-1] - nb_allumettes) if perdu : #le précédent coup de la machine a conduit à sa défaite : # on supprime le coup correspondant de la liste des coups possibles coups_possibles[allumettes[-4] - 1].remove(allumettes[-4] - allumettes[-3]) if perdu : parties_perdues.append(i) return (parties_perdues) . Exemples de situations possibles au bout d&#39;une partie . allumettes = [8, 7, 4, 2, 1, 0] on supprime le jeton 1 du gobelet 2 coups_possibles = [[1], [2], [1, 2, 3], [1, 2, 3], [1, 2, 3], [1, 2, 3], [1, 2, 3], [1, 2, 3]] | . allumettes = [8, 6, 5, 3, 2, 0] on supprime le jeton 1 du gobelet 3 coups_possibles = [[1], [1, 2], [2, 3], [1, 2, 3], [1, 2, 3], [1, 2, 3], [1, 2, 3], [1, 2, 3]] . | allumettes = [8, 7, 5, 4, 1, 0] on supprime le jeton 3 du gobelet 4 coups_possibles = [[1], [1, 2], [1, 2, 3], [1, 2], [1, 2, 3], [1, 2, 3], [1, 2, 3], [1, 2, 3]] . | . allumettes = [8, 5, 2, 0] on supprime le jeton 3 du gobelet 5 coups_possibles = [[1], [1, 2], [1, 2, 3], [1, 2, 3], [1, 2], [1, 2, 3], [1, 2, 3], [1, 2, 3]] . | allumettes = [8, 6, 3, 0] on supprime le jeton 3 du gobelet 6 coups_possibles = [[1], [1, 2], [1, 2, 3], [1, 2, 3], [1, 2, 3], [1, 2], [1, 2, 3], [1, 2, 3]] . | allumettes = [8, 6, 5, 3, 0] la machine a gagné ! coups_possibles = [[1], [1, 2], [1, 2, 3], [1, 2, 3], [1, 2, 3], [1, 2, 3], [1, 2, 3], [1, 2, 3]] . | . Exemples de situations n&#233;cessitant plus d&#39;une partie . allumettes = [8, 6, 5, 4, 4] avec coups_possibles[4] = []: on supprime le jeton 1 du gobelet 6 . | allumettes = [8, 7, 6, 4, 4] avec coups_possibles[4] = []: on supprime le jeton 1 du gobelet 7 . | . Simulation d&#39;un &#233;chantillon de parties jou&#233;es, affichage des rangs des parties perdues . coups_possibles = [[1], [1, 2]] + [[1,2,3] for i in range(NB_ALLUMETTES - 2)] parties_perdues = jouer_partie(100) print(&quot;parties perdues : &quot;, len(parties_perdues), parties_perdues) . parties perdues : 12 [0, 1, 3, 5, 6, 7, 11, 12, 18, 24, 89, 97] . print(coups_possibles) . [[1], [2], [3], [], [1], [2], [3], [1, 2, 3]] . Constat . La machine a appris à gagner à ce jeu : elle ignorait comment procéder au début et perdait fréquemment. Elle a appris de chaque partie perdue et obtient une stratégie qui s&#39;améliore au fil des parties, voire optimale si on la laisse jouer suffisamment de parties. Les parties jouées, réelles (version 1) ou simulées (version 2), sont les données sur lesquelles s’appuie son apprentissage. . Cette situation illustre le fait que la machine peut apprendre une stratégie que l’humain ne connait pas au départ, et dont la découverte aurait demandé à l’humain de faire preuve d’intelligence. Si l&#39;on retient de l&#39;intelligence artificielle la définition de Marvin Minsky, . L’intelligence artificielle est la science qui permet de faire réaliser à des machines des tâches qui nécessiteraient de l’intelligence si elles étaient réalisées par des humains. . peut-on considérer que la machine a fait preuve d&#39;intelligence artificielle ? . Simulation de parties jou&#233;es, affichage des rangs des derni&#232;res parties perdues . def simulation(nb_repetitions, nb_parties): global coups_possibles dernieres_perdues = [] for i in range(nb_repetitions): coups_possibles = [[1], [1, 2]] + [[1,2,3] for i in range(NB_ALLUMETTES - 2)] parties_perdues = jouer_partie(nb_parties) if len(parties_perdues) == 12: dernieres_perdues.append(parties_perdues[-1]) return dernieres_perdues . print(simulation(25, 200)) . [59, 71, 68, 77, 49, 36, 61, 31, 74, 17, 48, 61, 51, 121, 39, 69, 34, 56, 45, 46, 83, 63, 37, 86, 29] . def representation_graphique(n): plt.clf() dernieres_perdues = simulation(n, 300) plt.scatter(list(range(n)), dernieres_perdues, s = 8, c = &#39;r&#39;) moyenne = sum(dernieres_perdues)/len(dernieres_perdues) plt.axhline(moyenne) plt.title(&#39;Rang de la dernière partie perdue&#39;) plt.xlabel(&quot;numéro de l&#39;échantillon&quot;) plt.ylabel(&#39;rang de la dernière partie perdue&#39;) plt.show() . representation_graphique(200) . D&#39;après les simulations sur 200 échantillons, en moyenne, la machine devient experte au bout de 60 parties. . Si l&#39;on modifie la stratégie de jeu de l&#39;adversaire, cela influence-t-il ce paramètre ? . Influence de la strat&#233;gie de l&#39;adversaire . #L&#39;adversaire adopte une stratégie experte def jouer_adversaire(nb_allumettes): &#39;&#39;&#39; - prend en paramètre le nombre d&#39;allumettes restant à jouer - renvoie le nombre d&#39;allumettes prises lors du coup joué par l&#39;adversaire et un booléen indiquant si ce coup a conduit à la perte de la partie pour la machine &#39;&#39;&#39; perdu = False if nb_allumettes &lt; 4: coup_joue = nb_allumettes perdu = True elif nb_allumettes %4 != 0: coup_joue = nb_allumettes % 4 else : coup_joue = randint(1, 3) return (coup_joue, perdu) . representation_graphique(200) . Avec une stratégie experte, l&#39;adversaire impose à la machine de perdre dès que possible. En moyenne sur 200 réalisations, le rang de la dernière partie perdue est d&#39;environ 25. . Sources : . Quand une machine apprend à jouer au jeu de Nim (Marie Duflot), (CC BY SA) | . Pour aller plus loin : . Une machine en boites d&#39;alumettes qui apprend à jouer au morpion, Lisa Rougetet | Un jeu pour comprendre l&#39;apprentissage automatique, Florent Madelaine &amp; Malika More | La machine qui apprend à (bien) jouer toute seule, Eric Duchêne et Aline Parreau | .",
            "url": "https://nweibel.github.io/calepyns/2020/07/31/jeu_de_nim-Copy2.html",
            "relUrl": "/2020/07/31/jeu_de_nim-Copy2.html",
            "date": " • Jul 31, 2020"
        }
        
    
  
    
        ,"post6": {
            "title": "Le jeu de Nim par apprentissage",
            "content": "Les R&#232;gles du jeu . Nombre de joueurs : 2 . Principe : on dispose de 8 allumettes. Chaque joueur peut prendre 1, 2 ou 3 allumettes, à tour de rôle. Celui qui prend la dernière allumette gagne la partie. . . Remarque : . Le jeu de Nim est cité comme exemple d&#39;activité dans le thème E des programmes de mathématiques du cycle 4. . On peut par exemple programmer sur Scratch un jeu opposant un adversaire humain à &quot;l&#39;ordinateur&quot; : ici avec 12 &quot;bougies&quot;. . . Dans ce contexte, on écrit un algorithme qui décide ce que va jouer la machine. L&#39;agorithme attendu peut-être &quot;naïf&quot; : ou expert (pour une machine qui ne commence pas la partie) : . Différentes versions sont disponibles dans ce studio Scratch : https://scratch.mit.edu/studios/28731231/ . Objectif : . L&#39;un des joueurs est un humain, l&#39;autre joueur est &quot;une machine&quot;. Celle-ci doit apprendre à jouer contre son adversaire au fur et à mesure des parties jouées. . Cette activité présente ainsi une forme simple d&#39;apprentissage, à l&#39;issue duquel la machine aboutit à la stratégie gagnante à ce jeu. . Version 1 : sans ordinateur . Matériel : . 8 allumettes | 8 gobelets numérotés de 1 à 8 | 21 jetons : 8 jetons portant le n°1, 7 jetons portant le n°2 et 6 jetons portant le n°3. | . Chaque gobelet contient 3 jetons numérotés 1, 2, et 3, sauf le gobelet 1 qui ne contient qu&#39;un jeton numéroté 1, et le gobelet 2 qui ne contient que deux jetons numérotés 1 et 2. . . Déroulement: . Commencer une partie en laissant l&#39;humain jouer en premier. L&#39;humain joue comme il veut... . Lorsque c&#39;est à la machine de jouer, elle : . compte le nombre d&#39;allumettes restant et prend le gobelet correspondant, | pioche au hasard un jeton dans le gobelet, le pose sur la table juste devant ce gobelet, et pioche le nombre d&#39;allumettes indiqué par le jeton (1, 2 ou 3). | . En fin de partie, quand il n&#39;y a plus d&#39;allumettes, . soit la machine a gagné, et dans ce cas elle remet chaque jeton dans le gobelet où elle l&#39;a pioché, | soit elle a perdu et dans ce cas elle remet tous les jetons piochés sauf le dernier -- ce choix a permis à l&#39;humain de gagner -- et elle le met de côté. | . Au cours des parties successives, il peut arriver qu&#39;un gobelet soit vide. Dans ce cas on retourne le gobelet à l&#39;envers, et à partir de ce moment-là, si l&#39;adversaire laisse un nombre d&#39;allumettes pour lequel le gobelet est vide, la machine abandonne la partie, considère qu&#39;elle a perdu et remet tous les jetons piochés dans leur gobelet sauf le dernier. . Constats : . La machine va souvent perdre au début, mais au fil des parties elle va s&#39;améliorer et finir par suivre une stratégie qui la fera gagner à tous les coups. . Version 2 : programme Python . %matplotlib notebook from random import choice, randint import matplotlib.pyplot as plt . Jeu de la machine : . Les coups possibles au départ pour la machine sont de prendre 1, 2 ou 3 allumettes, s&#39;il en reste au moins 3. . S&#39;il n&#39;en reste que 2, elle peut en prendre 1 ou 2, et s&#39;il n&#39;en reste qu&#39;une, la machine la prend. . On modélise la situation par un tableau comportant la liste des coups possibles dans chaque cas : . coups_possibles = [[1], [1, 2]] + [[1,2,3] for i in range(NB_ALLUMETTES - 2)] où NB_ALLUMETTES est le nombre initial d&#39;allumettes, ici 8. . Lorsqu&#39;elle doit jouer, la machine choisit au hasard l&#39;un des coups possibles pour le nombre d&#39;allumettes restant. . Si aucun coup n&#39;est disponible, elle abandonne la partie qu&#39;elle considère comme perdue. . En fin de partie, si la machine a perdu, elle supprime de la liste des coups possibles le dernier coup réalisé. . def jouer_machine(nb_allumettes): &#39;&#39;&#39; - prend en paramètre le nombre d&#39;allumettes restant à jouer - renvoie le nombre d&#39;allumettes prises lors du coup joué par la machine et un booléen indiquant si la partie est perdue pour la machine &#39;&#39;&#39; perdu = False if coups_possibles[nb_allumettes - 1] != []: coup_joue = choice(coups_possibles[nb_allumettes - 1]) else : perdu = True coup_joue = 0 return (coup_joue, perdu) . Jeu de l&#39;adversaire: . L&#39;adversaire adopte une stratégie élémentaire : . S&#39;il reste au plus 3 allumettes, il les prend toutes -- et la partie est perdue pour la machine ; | sinon, il choisit aléatoirement, entre 1 et 3, le nombre d&#39;allumettes à prendre. | . #version xpert def jouer_adversaire(nb_allumettes): &#39;&#39;&#39; - prend en paramètre le nombre d&#39;allumettes restant à jouer - renvoie le nombre d&#39;allumettes prises lors du coup joué par l&#39;adversaire et un booléen indiquant si ce coup a conduit à la perte de la partie pour la machine &#39;&#39;&#39; perdu = False if nb_allumettes &lt; 4: coup_joue = nb_allumettes perdu = True elif nb_allumettes % 4 != 0: coup_joue = nb_allumettes % 4 else : coup_joue = randint(1, 3) return (coup_joue, perdu) . D&#233;roulement du jeu . NB_ALLUMETTES = 8 . def jouer_partie(n): &#39;&#39;&#39; simule le déroulement de n parties successives, en faisant toujours commencer l&#39;adversaire de la machine et renvoie la liste des rangs des parties perdues &#39;&#39;&#39; parties_perdues = [] for i in range(n): perdu = False # perdu prend la valeur True lorsque la machine perd la partie allumettes = [NB_ALLUMETTES] # contient les valeurs successives au # cours d&#39;une partie du nombre d&#39;allumettes restantes while not perdu and allumettes[-1] &gt; 0 : #l&#39;adversaire joue nb_allumettes, perdu = jouer_adversaire(allumettes[-1]) allumettes.append(allumettes[-1] - nb_allumettes) if perdu : # le dernier coup de la machine a permis à l&#39;adversaire de # gagner : on supprime le coup correspondant de la # liste des coups possibles coups_possibles[allumettes[-3] - 1].remove(allumettes[-3] - allumettes[-2]) else : # la machine joue nb_allumettes, perdu = jouer_machine(allumettes[-1]) allumettes.append(allumettes[-1] - nb_allumettes) if perdu : #le précédent coup de la machine a conduit à sa défaite : # on supprime le coup correspondant de la liste des coups possibles coups_possibles[allumettes[-4] - 1].remove(allumettes[-4] - allumettes[-3]) if perdu : parties_perdues.append(i) return (parties_perdues) . Exemples de situations possibles au bout d&#39;une partie . allumettes = [8, 7, 4, 2, 1, 0] . on supprime le jeton 1 du gobelet 2 coups_possibles = [[1], [2], [1, 2, 3], [1, 2, 3], [1, 2, 3], [1, 2, 3], [1, 2, 3], [1, 2, 3]] . allumettes = [8, 6, 5, 3, 2, 0] . on supprime le jeton 1 du gobelet 3 coups_possibles = [[1], [1, 2], [2, 3], [1, 2, 3], [1, 2, 3], [1, 2, 3], [1, 2, 3], [1, 2, 3]] . allumettes = [8, 7, 5, 4, 1, 0] . on supprime le jeton 3 du gobelet 4 coups_possibles = [[1], [1, 2], [1, 2, 3], [1, 2], [1, 2, 3], [1, 2, 3], [1, 2, 3], [1, 2, 3]] . allumettes = [8, 5, 2, 0] . on supprime le jeton 3 du gobelet 5 coups_possibles = [[1], [1, 2], [1, 2, 3], [1, 2, 3], [1, 2], [1, 2, 3], [1, 2, 3], [1, 2, 3]] . allumettes = [8, 6, 3, 0] . on supprime le jeton 3 du gobelet 6 coups_possibles = [[1], [1, 2], [1, 2, 3], [1, 2, 3], [1, 2, 3], [1, 2], [1, 2, 3], [1, 2, 3]] . allumettes = [8, 6, 5, 3, 0] . la machine a gagné ! . coups_possibles = [[1], [1, 2], [1, 2, 3], [1, 2, 3], [1, 2, 3], [1, 2, 3], [1, 2, 3], [1, 2, 3]] . Exemples de situations n&#233;cessitant plus d&#39;une partie . allumettes = [8, 6, 5, 4, 4] . avec coups_possibles[4] = []: on supprime le jeton 1 du gobelet 6 . allumettes = [8, 7, 6, 4, 4] . avec coups_possibles[4] = [] : on supprime le jeton 1 du gobelet 7 . Simulation d&#39;un &#233;chantillon de parties jou&#233;es, affichage des rangs des parties perdues . coups_possibles = [[1], [1, 2]] + [[1,2,3] for i in range(NB_ALLUMETTES - 2)] parties_perdues = jouer_partie(300) print(&quot;parties perdues : &quot;, len(parties_perdues), parties_perdues) . parties perdues : 12 [0, 1, 2, 5, 10, 12, 13, 15, 17, 18, 21, 24] . print(coups_possibles) . [[1], [2], [3], [], [1], [2], [3], [1, 2, 3]] . Constat . La machine a appris à gagner à ce jeu : elle ignorait comment faire au début et perdait fréquemment. Elle a appris de chaque partie perdue et obtient une stratégie parfaite. Les parties jouées, réelles (version 1) ou simulées (version 2), sont les données sur lesquelles s’appuie son apprentissage. Elle illustre bien que la machine peut apprendre une stratégie que l’humain ne connaissait pas au départ, et qui lui aurait demandé (à l’humain) de l’intelligence pour la découvrir. . Simulation d&#39;un nombre variable d&#39;&#233;chantillons de parties jou&#233;es, affichage des rangs des derni&#232;res parties perdues . def simulation(nb_echantillons, taille_echantillon): global coups_possibles dernieres_perdues = [] for i in range(nb_echantillons): coups_possibles = [[1], [1, 2]] + [[1,2,3] for i in range(NB_ALLUMETTES - 2)] parties_perdues = jouer_partie(taille_echantillon) if len(parties_perdues) == 12: dernieres_perdues.append(parties_perdues[-1]) else: dernieres_perdues.append(300) return dernieres_perdues . print(simulation(25, 300)) . [15, 28, 23, 30, 19, 26, 24, 16, 22, 21, 19, 16, 24, 20, 26, 20, 24, 23, 30, 20, 41, 20, 18, 17, 22] . def representation_graphique(n): dernieres_perdues = simulation(n, 400) plt.scatter(list(range(n)), dernieres_perdues, s = 8, c = &#39;r&#39;) moyenne = sum(dernieres_perdues)/len(dernieres_perdues) plt.axhline(moyenne) plt.title(&#39;Rang de la dernière partie perdue&#39;) plt.xlabel(&quot;numéro de l&#39;échantillon&quot;) plt.ylabel(&#39;rang de la dernière partie perdue&#39;) plt.show() . representation_graphique(500) . Sources : . Quand une machine apprend à jouer au jeu de Nim (Marie Duflot), (CC BY SA) | . Pour aller plus loin : . Une machine en boites d&#39;alumettes qui apprend à jouer au morpion, Lisa Rougetet | Un jeu pour comprendre l&#39;apprentissage automatique, Florent Madelaine &amp; Malika More | La machine qui apprend à (bien) jouer toute seule, Eric Duchêne et Aline Parreau | . .",
            "url": "https://nweibel.github.io/calepyns/jupyter/jeu/2020/07/31/jeu_de_nim-Copy1.html",
            "relUrl": "/jupyter/jeu/2020/07/31/jeu_de_nim-Copy1.html",
            "date": " • Jul 31, 2020"
        }
        
    
  
    
        ,"post7": {
            "title": "Ici ou là",
            "content": ". Note: Consulter le notebook complet (avec les cartes) sur Jupyter nbviewer. . L&#39;objectif est de représenter sur une carte géographique la localisation de communes dont le nom respecte certains critères, comme le fait de commencer ou terminer par certaines chaînes de caractères. . import csv import folium . with open(&#39;villes_france.csv&#39;,&#39;r&#39;, encoding =&#39;utf-8&#39;) as fichier: lecteur = csv.DictReader(fichier, delimiter=&#39;;&#39;) donnees = [dict(ligne) for ligne in lecteur] . #formatage des départements, CP et code_insee for commune in donnees: if len(commune[&#39;dept&#39;])==1: commune[&#39;dept&#39;] = &#39;0&#39;+ commune[&#39;dept&#39;] if len(commune[&#39;CP&#39;])==4: commune[&#39;CP&#39;] = &#39;0&#39;+ commune[&#39;CP&#39;] if len(commune[&#39;Code_insee&#39;])==4: commune[&#39;Code_insee&#39;] = &#39;0&#39;+ commune[&#39;Code_insee&#39;] . #aperçu des données donnees[0] . {&#39;nb&#39;: &#39;1&#39;, &#39;dept&#39;: &#39;01&#39;, &#39;COMMUNE&#39;: &#39;OZAN&#39;, &#39;Commune&#39;: &#39;Ozan&#39;, &#39;CP&#39;: &#39;01190&#39;, &#39;Code_insee&#39;: &#39;01284&#39;, &#39;longitude&#39;: &#39;4.91667&#39;, &#39;latitude&#39;: &#39;46.3833&#39;} . Localisation de quelques suffixes ou terminaisons des noms de communes . carte = folium.Map(location = [47,2], zoom_start = 6) for commune in donnees: couleur = &#39;&#39; if commune[&#39;COMMUNE&#39;].endswith(&#39;VILLE&#39;): couleur = &#39;ForestGreen&#39; elif commune[&#39;COMMUNE&#39;].endswith(&#39;BOURG&#39;): couleur = &#39;orange&#39; elif commune[&#39;COMMUNE&#39;].endswith(&#39;AC&#39;): couleur = &#39;crimson&#39; elif commune[&#39;COMMUNE&#39;].endswith(&#39;HEIM&#39;): couleur = &#39;navy&#39; elif commune[&#39;COMMUNE&#39;].endswith(&#39;COURT&#39;): couleur = &#39;Magenta&#39; elif commune[&#39;COMMUNE&#39;].endswith(&#39;MER&#39;): couleur = &#39;blue&#39; elif commune[&#39;COMMUNE&#39;].endswith(&#39;LOIRE&#39;): couleur = &#39;LightSeaGreen&#39; elif commune[&#39;COMMUNE&#39;].endswith(&#39;AY&#39;): couleur = &#39;Purple&#39; elif commune[&#39;COMMUNE&#39;].endswith(&#39;BAINS&#39;): couleur = &#39;cyan&#39; elif commune[&#39;COMMUNE&#39;].endswith(&#39;HEM&#39;): couleur = &#39;tomato&#39; if couleur != &#39;&#39;: message = commune[&#39;Commune&#39;] + &#39; (&#39; + commune[&#39;dept&#39;] + &#39; )&#39; coordonnees = [float(commune[&#39;latitude&#39;]), float(commune[&#39;longitude&#39;])] folium.CircleMarker(location = coordonnees, radius = 1, #rayon du cercle color = couleur, tooltip = message ).add_to(carte) carte . Localisation de quelques d&#233;buts des noms de communes . carte2 = folium.Map(location = [47,2], zoom_start = 6) for commune in donnees: couleur = &#39;&#39; if commune[&#39;COMMUNE&#39;].startswith(&#39;PL&#39;): couleur = &#39;crimson&#39; elif commune[&#39;COMMUNE&#39;].startswith(&#39;CA&#39;): couleur = &#39;blue&#39; elif commune[&#39;COMMUNE&#39;].startswith(&#39;CH&#39;): couleur = &#39;green&#39; elif commune[&#39;COMMUNE&#39;].startswith(&#39;W&#39;): couleur = &#39;orange&#39; elif commune[&#39;COMMUNE&#39;].startswith(&#39;K&#39;): couleur = &#39;cyan&#39; if couleur != &#39;&#39;: message = commune[&#39;Commune&#39;] + &#39; (&#39; + commune[&#39;dept&#39;] + &#39; )&#39; coordonnees = [float(commune[&#39;latitude&#39;]), float(commune[&#39;longitude&#39;])] folium.CircleMarker(location = coordonnees, radius = 1, #rayon du cercle color = couleur, tooltip = message ).add_to(carte2) carte2 .",
            "url": "https://nweibel.github.io/calepyns/jupyter/folium/csv/2020/07/30/villes_en_france.html",
            "relUrl": "/jupyter/folium/csv/2020/07/30/villes_en_france.html",
            "date": " • Jul 30, 2020"
        }
        
    
  
    
        ,"post8": {
            "title": "Fastpages Notebook Blog Post",
            "content": "About . This notebook is a demonstration of some of capabilities of fastpages with notebooks. . With fastpages you can save your jupyter notebooks into the _notebooks folder at the root of your repository, and they will be automatically be converted to Jekyll compliant blog posts! . Front Matter . The first cell in your Jupyter Notebook or markdown blog post contains front matter. Front matter is metadata that can turn on/off options in your Notebook. It is formatted like this: . # &quot;My Title&quot; &gt; &quot;Awesome summary&quot; - toc:true- branch: master- badges: true- comments: true - author: Hamel Husain &amp; Jeremy Howard - categories: [fastpages, jupyter] . Setting toc: true will automatically generate a table of contents | Setting badges: true will automatically include GitHub and Google Colab links to your notebook. | Setting comments: true will enable commenting on your blog post, powered by utterances. | . The title and description need to be enclosed in double quotes only if they include special characters such as a colon. More details and options for front matter can be viewed on the front matter section of the README. . Markdown Shortcuts . A #hide comment at the top of any code cell will hide both the input and output of that cell in your blog post. . A #hide_input comment at the top of any code cell will only hide the input of that cell. . The comment #hide_input was used to hide the code that produced this. . put a #collapse-hide flag at the top of any cell if you want to hide that cell by default, but give the reader the option to show it: . #collapse-hide import pandas as pd import altair as alt . . put a #collapse-show flag at the top of any cell if you want to show that cell by default, but give the reader the option to hide it: . #collapse-show cars = &#39;https://vega.github.io/vega-datasets/data/cars.json&#39; movies = &#39;https://vega.github.io/vega-datasets/data/movies.json&#39; sp500 = &#39;https://vega.github.io/vega-datasets/data/sp500.csv&#39; stocks = &#39;https://vega.github.io/vega-datasets/data/stocks.csv&#39; flights = &#39;https://vega.github.io/vega-datasets/data/flights-5k.json&#39; . . Interactive Charts With Altair . Charts made with Altair remain interactive. Example charts taken from this repo, specifically this notebook. . Example 1: DropDown . # single-value selection over [Major_Genre, MPAA_Rating] pairs # use specific hard-wired values as the initial selected values selection = alt.selection_single( name=&#39;Select&#39;, fields=[&#39;Major_Genre&#39;, &#39;MPAA_Rating&#39;], init={&#39;Major_Genre&#39;: &#39;Drama&#39;, &#39;MPAA_Rating&#39;: &#39;R&#39;}, bind={&#39;Major_Genre&#39;: alt.binding_select(options=genres), &#39;MPAA_Rating&#39;: alt.binding_radio(options=mpaa)} ) # scatter plot, modify opacity based on selection alt.Chart(movies).mark_circle().add_selection( selection ).encode( x=&#39;Rotten_Tomatoes_Rating:Q&#39;, y=&#39;IMDB_Rating:Q&#39;, tooltip=&#39;Title:N&#39;, opacity=alt.condition(selection, alt.value(0.75), alt.value(0.05)) ) . Example 2: Tooltips . alt.Chart(movies).mark_circle().add_selection( alt.selection_interval(bind=&#39;scales&#39;, encodings=[&#39;x&#39;]) ).encode( x=&#39;Rotten_Tomatoes_Rating:Q&#39;, y=alt.Y(&#39;IMDB_Rating:Q&#39;, axis=alt.Axis(minExtent=30)), # use min extent to stabilize axis title placement tooltip=[&#39;Title:N&#39;, &#39;Release_Date:N&#39;, &#39;IMDB_Rating:Q&#39;, &#39;Rotten_Tomatoes_Rating:Q&#39;] ).properties( width=600, height=400 ) . Example 3: More Tooltips . # select a point for which to provide details-on-demand label = alt.selection_single( encodings=[&#39;x&#39;], # limit selection to x-axis value on=&#39;mouseover&#39;, # select on mouseover events nearest=True, # select data point nearest the cursor empty=&#39;none&#39; # empty selection includes no data points ) # define our base line chart of stock prices base = alt.Chart().mark_line().encode( alt.X(&#39;date:T&#39;), alt.Y(&#39;price:Q&#39;, scale=alt.Scale(type=&#39;log&#39;)), alt.Color(&#39;symbol:N&#39;) ) alt.layer( base, # base line chart # add a rule mark to serve as a guide line alt.Chart().mark_rule(color=&#39;#aaa&#39;).encode( x=&#39;date:T&#39; ).transform_filter(label), # add circle marks for selected time points, hide unselected points base.mark_circle().encode( opacity=alt.condition(label, alt.value(1), alt.value(0)) ).add_selection(label), # add white stroked text to provide a legible background for labels base.mark_text(align=&#39;left&#39;, dx=5, dy=-5, stroke=&#39;white&#39;, strokeWidth=2).encode( text=&#39;price:Q&#39; ).transform_filter(label), # add text labels for stock prices base.mark_text(align=&#39;left&#39;, dx=5, dy=-5).encode( text=&#39;price:Q&#39; ).transform_filter(label), data=stocks ).properties( width=700, height=400 ) . Data Tables . You can display tables per the usual way in your blog: . movies = &#39;https://vega.github.io/vega-datasets/data/movies.json&#39; df = pd.read_json(movies) # display table with pandas df[[&#39;Title&#39;, &#39;Worldwide_Gross&#39;, &#39;Production_Budget&#39;, &#39;Distributor&#39;, &#39;MPAA_Rating&#39;, &#39;IMDB_Rating&#39;, &#39;Rotten_Tomatoes_Rating&#39;]].head() . Title Worldwide_Gross Production_Budget Distributor MPAA_Rating IMDB_Rating Rotten_Tomatoes_Rating . 0 The Land Girls | 146083.0 | 8000000.0 | Gramercy | R | 6.1 | NaN | . 1 First Love, Last Rites | 10876.0 | 300000.0 | Strand | R | 6.9 | NaN | . 2 I Married a Strange Person | 203134.0 | 250000.0 | Lionsgate | None | 6.8 | NaN | . 3 Let&#39;s Talk About Sex | 373615.0 | 300000.0 | Fine Line | None | NaN | 13.0 | . 4 Slam | 1087521.0 | 1000000.0 | Trimark | R | 3.4 | 62.0 | . Images . Local Images . You can reference local images and they will be copied and rendered on your blog automatically. You can include these with the following markdown syntax: . ![](my_icons/fastai_logo.png) . . Remote Images . Remote images can be included with the following markdown syntax: . ![](https://image.flaticon.com/icons/svg/36/36686.svg) . . Animated Gifs . Animated Gifs work, too! . ![](https://upload.wikimedia.org/wikipedia/commons/7/71/ChessPawnSpecialMoves.gif) . . Captions . You can include captions with markdown images like this: . ![](https://www.fast.ai/images/fastai_paper/show_batch.png &quot;Credit: https://www.fast.ai/2020/02/13/fastai-A-Layered-API-for-Deep-Learning/&quot;) . . Other Elements . GitHub Flavored Emojis . Typing I give this post two :+1:! will render this: . I give this post two :+1:! . Tweetcards . Typing &gt; twitter: https://twitter.com/jakevdp/status/1204765621767901185?s=20 will render this: Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 . Youtube Videos . Typing &gt; youtube: https://youtu.be/XfoYk_Z5AkI will render this: . Boxes / Callouts . Typing &gt; Warning: There will be no second warning! will render this: . Warning: There will be no second warning! . Typing &gt; Important: Pay attention! It&#39;s important. will render this: . Important: Pay attention! It&#8217;s important. . Typing &gt; Tip: This is my tip. will render this: . Tip: This is my tip. . Typing &gt; Note: Take note of this. will render this: . Note: Take note of this. . Typing &gt; Note: A doc link to [an example website: fast.ai](https://www.fast.ai/) should also work fine. will render in the docs: . Note: A doc link to an example website: fast.ai should also work fine. . Footnotes . You can have footnotes in notebooks, however the syntax is different compared to markdown documents. This guide provides more detail about this syntax, which looks like this: . For example, here is a footnote {% fn 1 %}. And another {% fn 2 %} {{ &#39;This is the footnote.&#39; | fndetail: 1 }} {{ &#39;This is the other footnote. You can even have a [link](www.github.com)!&#39; | fndetail: 2 }} . For example, here is a footnote 1. . And another 2 . 1. This is the footnote.↩ . 2. This is the other footnote. You can even have a link!↩ .",
            "url": "https://nweibel.github.io/calepyns/jupyter/2020/02/20/test.html",
            "relUrl": "/jupyter/2020/02/20/test.html",
            "date": " • Feb 20, 2020"
        }
        
    
  
    
        ,"post9": {
            "title": "An Example Markdown Post",
            "content": "Example Markdown Post . Basic setup . Jekyll requires blog post files to be named according to the following format: . YEAR-MONTH-DAY-filename.md . Where YEAR is a four-digit number, MONTH and DAY are both two-digit numbers, and filename is whatever file name you choose, to remind yourself what this post is about. .md is the file extension for markdown files. . The first line of the file should start with a single hash character, then a space, then your title. This is how you create a “level 1 heading” in markdown. Then you can create level 2, 3, etc headings as you wish but repeating the hash character, such as you see in the line ## File names above. . Basic formatting . You can use italics, bold, code font text, and create links. Here’s a footnote 1. Here’s a horizontal rule: . . Lists . Here’s a list: . item 1 | item 2 | . And a numbered list: . item 1 | item 2 | Boxes and stuff . This is a quotation . . You can include alert boxes …and… . . You can include info boxes Images . . Code . You can format text and code per usual . General preformatted text: . # Do a thing do_thing() . Python code and output: . # Prints &#39;2&#39; print(1+1) . 2 . Formatting text as shell commands: . echo &quot;hello world&quot; ./some_script.sh --option &quot;value&quot; wget https://example.com/cat_photo1.png . Formatting text as YAML: . key: value - another_key: &quot;another value&quot; . Tables . Column 1 Column 2 . A thing | Another thing | . Tweetcards . Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 Footnotes . This is the footnote. &#8617; . |",
            "url": "https://nweibel.github.io/calepyns/markdown/2020/01/14/test-markdown-post.html",
            "relUrl": "/markdown/2020/01/14/test-markdown-post.html",
            "date": " • Jan 14, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "À propos",
          "content": "Les notebooks présentés sur ce site sont réalisés pour l’enseignement, la formation ou par simple curiosité. Ils sont partagés selon les termes de la Licence Creative Commons Attribution - Partage dans les Mêmes Conditions 4.0. . Ces pages sont réalisées avec fastpages 1. . une plateforme de blog qui supporte nativement les notebooks Jupyter et d’autres formats. &#8617; . |",
          "url": "https://nweibel.github.io/calepyns/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://nweibel.github.io/calepyns/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}