{
  
    
        "post0": {
            "title": "Une histoire de tiroirs",
            "content": "Voici quelques extraits d&#39;un article de Jean-Paul Delahaye, publié dans Pour la science 483 en janvier 2018 : . Si l’on se donne 10 entiers quelconques composés de deux chiffres, il existe parmi eux deux sous-ensembles disjoints de nombres ayant la même somme. Par exemple, si l’on se donne {23, 35, 44, 61, 68, 70, 71, 82, 83, 95}, on trouvera que {23, 35, 95} donne la même somme que {71, 82} :23 + 35 + 95 = 153 = 71 + 82 . Démonstration :Les sous-ensembles possibles de notre ensemble de 10 entiers sont aunombre de $2^{10}$ = 1 024, car pour constituer un tel sous-ensemble, on opère 10 fois de suite le choix binaire : prendre le nombre ou ne pas le prendre. Quels nombres peut-on atteindre en faisant la somme des nombres de nos sous-ensembles ? Un sous-ensemble comporte de 0 à 10 nombres compris entre 10 et 99 ; la somme est donc comprise entre 0 et 10 fois 99, donc entre 0 et 990. En numérotant 991 tiroirs de 0 à 990, et en plaçant chaque sous-ensemble possible dans le tiroir dont le numéro est la somme de ses éléments, on trouve d’après le principe des tiroirs deux sous-ensembles ayant la même somme. Le problème n’est cependant pas vraiment résolu, car on nous demande de trouver des sous-ensembles disjoints ayant la même somme, et rien ne nous permet d’affirmer que les deux sous-ensembles trouvés à l’instant le sont. Ce n’est pas très grave :si les sous-ensembles ontdes éléments en commun, on les enlève. Les deux sous-ensembles alors obtenus ont encore la même somme, car on a enlevé les mêmes éléments, et cette fois ce sont deux sous-ensembles disjoints. . Ce résultat assure l&#39;existence d&#39;au moins une solution. L&#39;objectif est ici d&#39;exhiber toutes les solutions pour un ensemble de 10 entiers aléatoires entre 10 et 99. . G&#233;n&#233;rer un tableau de 10 entiers distincts . Les dix entiers sont compris entre 10 et 99 | Ils sont distincts | . from random import randint def genere_dix_entiers(): entiers = [] while len(entiers) &lt; 10: nouvel_entier = randint(10,99) if nouvel_entier not in entiers : entiers.append(nouvel_entier) else: pass return(entiers) . G&#233;n&#233;rer toutes les parties d&#39;un ensemble . Trois méthodes sont proposées : une seule suffit, mais cela permet de choisir celle qui convient le mieux au contexte. . M&#233;thode 1 : construction par ajout d&#39;&#233;lements successifs . def partiesliste1(liste): &quot;&quot;&quot; genere toutes les parties de l&#39;ensemble des éléments de liste &gt;&gt;&gt; partiesliste1([1,2,3]) [[1, 2, 3], [2, 3], [1, 3], [3], [1, 2], [2], [1], []] &quot;&quot;&quot; parties = [[]] while liste: premier = liste[0] liste = liste[1:] construction = [x + [premier] for x in parties] + parties parties = construction return parties . M&#233;thode 2 : construction &#224; l&#39;aide du binaire . def partiesliste2(liste): &quot;&quot;&quot; genere toutes les parties de l&#39;ensemble des éléments de liste pour une valeur du compteur i, s&#39;il y a un &#39;1&#39; en j-ème position du compteur en binaire, alors on ajoute le j-ème élément dans la liste correspondant à ce compteur. &gt;&gt;&gt; partiesliste2([1,2,3]) [[], [1], [2], [1, 2], [3], [1, 3], [2, 3], [1, 2, 3]] &quot;&quot;&quot; parties = [] for i in range(2**len(liste)): nouveau = [] for j in range(len(liste)): if (i &gt;&gt; j) &amp; 1 == 1: # si l&#39;écriture binaire de i comporte un 1 en j-eme position nouveau.append(liste[j]) parties.append(nouveau) return parties . M&#233;thode 3 : utilisation du module itertools . import itertools def partiesliste3(liste): &quot;&quot;&quot; genere toutes les parties de l&#39;ensemble des éléments de liste, de taille croissante &gt;&gt;&gt; partiesliste3([1,2,3]) [[], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]] &quot;&quot;&quot; parties = [] for i in range(0, len(liste)+1): for partie in itertools.combinations(liste, i): parties.append(list(partie)) return parties . Calculer la somme des &#233;l&#233;ments de chaque partie . def calcule_sommes(liste_parties): sommes = {} for partie in liste_parties: somme = sum(partie) if somme not in sommes : sommes[somme] = [partie] else : sommes[somme].append(partie) return sommes . Rechercher les &#233;l&#233;ments d&#39;un dictionnaire dont la valeur a une longueur d&#39;au moins 2. . def recherche_sommes_communes(dico): sommes_communes = {} for cle in dico: if len(dico[cle]) &gt; 1 : sommes_communes[cle] = dico[cle] return sommes_communes . Supprimer les listes non disjointes . def nettoyage(dico): &quot;&quot;&quot; crée un dictionnaire contenant les clés de dico, lorsqu&#39;au moins deux listes disjointes ont cette valeur pour somme Les valeurs associées à la clé sont les paires de deux ensembles disjoints dont la somme est la clé &quot;&quot;&quot; sommes_nettoyees={} for cle in dico: tableau = (dico[cle]) for i in range(len(tableau)): for j in range(i+1,len(tableau)): if set(tableau[i]).isdisjoint(set(tableau[j])): if cle not in sommes_nettoyees : sommes_nettoyees[cle] = [[set(tableau[i]), set(tableau[j])]] else : sommes_nettoyees[cle].append([set(tableau[i]), set(tableau[j])]) return sommes_nettoyees . Voir les solutions . mes_dix_nombres = genere_dix_entiers() mes_dix_nombres . [44, 79, 15, 74, 72, 18, 54, 19, 14, 97] . mes_sommes_communes = recherche_sommes_communes(calcule_sommes(partiesliste2(mes_dix_nombres))) . solutions = nettoyage(mes_sommes_communes) print(&quot;Liste ordonnée des sommes que l&#39;on peut obtenir à partir d&#39;au moins deux sous-ensembles distincts de la liste &quot;, mes_dix_nombres,&quot; : n&quot;, sorted([cle for cle in solutions])) solutions . Liste ordonnée des sommes que l&#39;on peut obtenir à partir d&#39;au moins deux sous-ensembles distincts de la liste [44, 79, 15, 74, 72, 18, 54, 19, 14, 97] : [33, 72, 73, 87, 88, 91, 92, 93, 97, 98, 106, 111, 112, 116, 123, 126, 130, 133, 141, 142, 146, 148, 151, 153, 155, 159, 160, 165, 169, 170, 171, 176, 184, 185, 187, 189, 190, 191, 194, 205, 206, 207, 209, 216, 221, 234, 243] . {123: [[{44, 79}, {14, 18, 19, 72}]], 153: [[{74, 79}, {18, 19, 44, 72}]], 133: [[{15, 44, 74}, {54, 79}]], 72: [[{72}, {18, 54}]], 116: [[{44, 72}, {18, 19, 79}], [{44, 72}, {19, 97}], [{18, 44, 54}, {19, 97}]], 151: [[{72, 79}, {15, 18, 44, 74}], [{72, 79}, {14, 19, 44, 74}], [{72, 79}, {54, 97}], [{15, 18, 44, 74}, {54, 97}], [{18, 54, 79}, {14, 19, 44, 74}], [{14, 19, 44, 74}, {54, 97}]], 87: [[{15, 72}, {14, 19, 54}]], 146: [[{72, 74}, {14, 15, 19, 44, 54}]], 190: [[{44, 72, 74}, {14, 79, 97}], [{18, 44, 54, 74}, {14, 79, 97}]], 205: [[{54, 72, 79}, {15, 19, 74, 97}]], 97: [[{18, 79}, {97}]], 141: [[{18, 44, 79}, {15, 54, 72}], [{15, 54, 72}, {44, 97}]], 33: [[{15, 18}, {14, 19}]], 112: [[{15, 18, 79}, {14, 44, 54}], [{14, 44, 54}, {15, 97}], [{14, 19, 79}, {15, 97}]], 92: [[{18, 74}, {14, 15, 19, 44}]], 171: [[{14, 15, 19, 44, 79}, {74, 97}]], 169: [[{14, 18, 19, 44, 74}, {72, 97}]], 184: [[{15, 18, 72, 79}, {14, 19, 54, 97}], [{14, 19, 72, 79}, {15, 18, 54, 97}], [{14, 18, 19, 54, 79}, {15, 72, 97}]], 243: [[{18, 72, 74, 79}, {14, 15, 19, 44, 54, 97}], [{14, 15, 19, 44, 72, 79}, {18, 54, 74, 97}], [{14, 15, 18, 19, 44, 54, 79}, {72, 74, 97}]], 98: [[{44, 54}, {19, 79}]], 148: [[{15, 54, 79}, {14, 18, 44, 72}], [{15, 54, 79}, {14, 18, 19, 97}]], 207: [[{54, 74, 79}, {14, 15, 18, 19, 44, 97}]], 187: [[{15, 44, 54, 74}, {18, 72, 97}], [{15, 19, 74, 79}, {18, 72, 97}]], 126: [[{54, 72}, {15, 18, 19, 74}], [{54, 72}, {14, 15, 18, 79}], [{54, 72}, {14, 15, 97}]], 170: [[{19, 72, 79}, {14, 15, 44, 97}], [{18, 19, 54, 79}, {14, 15, 44, 97}], [{14, 15, 18, 44, 79}, {19, 54, 97}]], 185: [[{15, 44, 54, 72}, {14, 18, 74, 79}], [{15, 44, 54, 72}, {14, 74, 97}], [{15, 19, 72, 79}, {14, 74, 97}], [{15, 18, 19, 54, 79}, {14, 74, 97}], [{14, 18, 74, 79}, {15, 19, 54, 97}]], 159: [[{14, 19, 54, 72}, {18, 44, 97}]], 142: [[{19, 44, 79}, {14, 54, 74}]], 93: [[{19, 74}, {14, 79}]], 216: [[{19, 44, 74, 79}, {14, 15, 18, 72, 97}]], 91: [[{19, 72}, {14, 15, 18, 44}]], 106: [[{15, 19, 72}, {14, 18, 74}]], 165: [[{19, 72, 74}, {14, 18, 54, 79}], [{19, 72, 74}, {14, 54, 97}], [{18, 19, 54, 74}, {14, 72, 79}]], 209: [[{19, 44, 72, 74}, {15, 18, 79, 97}]], 160: [[{18, 19, 44, 79}, {14, 72, 74}], [{14, 72, 74}, {19, 44, 97}], [{14, 18, 54, 74}, {19, 44, 97}]], 111: [[{18, 19, 74}, {14, 97}]], 155: [[{18, 19, 44, 74}, {14, 15, 54, 72}]], 234: [[{15, 19, 54, 72, 74}, {14, 44, 79, 97}], [{14, 15, 54, 72, 79}, {19, 44, 74, 97}]], 73: [[{19, 54}, {14, 15, 44}]], 88: [[{15, 19, 54}, {14, 74}]], 191: [[{19, 44, 54, 74}, {15, 79, 97}]], 206: [[{14, 15, 44, 54, 79}, {18, 19, 72, 97}]], 189: [[{19, 44, 54, 72}, {18, 74, 97}]], 130: [[{14, 44, 72}, {15, 18, 97}]], 221: [[{14, 54, 74, 79}, {15, 18, 19, 72, 97}]], 194: [[{14, 15, 19, 72, 74}, {18, 79, 97}]], 176: [[{14, 15, 19, 54, 74}, {79, 97}]]} . compteur = 0 for cle in solutions: compteur = compteur + len(solutions[cle]) compteur . 77 .",
            "url": "https://nweibel.github.io/calepyns/jupyter/binaire/combinaisons/2020/08/18/tiroirs.html",
            "relUrl": "/jupyter/binaire/combinaisons/2020/08/18/tiroirs.html",
            "date": " • Aug 18, 2020"
        }
        
    
  
    
        ,"post1": {
            "title": "Le jeu de Nim par apprentissage",
            "content": "%matplotlib notebook from random import choice, randint import matplotlib.pyplot as plt . Les R&#232;gles du jeu . Nombre de joueurs : 2 . Principe : on dispose de 8 allumettes. Chaque joueur peut prendre 1, 2 ou 3 allumettes, à tour de rôle. Celui qui prend la dernière allumette gagne la partie. . . Objectif : L&#39;un des joueurs est un humain, l&#39;autre joueur est &quot;une machine&quot;. Celle-ci doit apprendre à jouer contre son adversaire au fur et à mesure des parties jouées. . Cette activité a pour but de présenter une intelligence artificielle, plus particulièrement une forme simple d&#39;apprentissage, et de montrer qu&#39;en effectuant des actions élémentaires notre machine peut réussir à trouver la stratégie gagnante à ce jeu. . Version 1 : sans ordinateur . Matériel : . 8 allumettes | 8 gobelets numérotés de 1 à 8 | 21 jetons : 8 jetons portant le n°1, 7 jetons portant le n°2 et 6 jetons portant le n°3. | . Chaque gobelet contient 3 jetons numérotés 1, 2, et 3, sauf le gobelet 1 qui ne contient qu&#39;un jeton numéroté 1, et le gobelet 2 qui ne contient que deux jetons numérotés 1 et 2. . . Déroulement: . Commencer une partie en laissant l&#39;humain jouer en premier. L&#39;humain joue comme il veut... . Lorsque c&#39;est à la machine de jouer, elle : . compte le nombre d&#39;allumettes restant et prend le gobelet correspondant, | pioche au hasard un jeton dans le gobelet, le pose sur la table juste devant ce gobelet, et pioche le nombre d&#39;allumettes indiqué par le jeton (1, 2 ou 3). | . En fin de partie, quand il n&#39;y a plus d&#39;allumettes, . soit la machine a gagné, et dans ce cas elle remet chaque jeton dans le gobelet où elle l&#39;a pioché, | soit elle a perdu et dans ce cas elle remet tous les jetons piochés sauf le dernier -- ce choix a permis à l&#39;humain de gagner -- et elle le met de côté. | . Au cours des parties successives, il peut arriver qu&#39;un gobelet soit vide. Dans ce cas on retourne le gobelet à l&#39;envers, et à partir de ce moment-là, si l&#39;adversaire laisse un nombre d&#39;allumettes pour lequel le gobelet est vide, la machine abandonne la partie, considère qu&#39;elle a perdu et remet tous les jetons piochés dans leur gobelet sauf le dernier. . Constats : . La machine va souvent perdre au début, mais au fil des parties elle va s&#39;améliorer et finir par suivre une stratégie qui la fera gagner à tous les coups. . Version 2 : programme Python . Jeu de la machine : . Les coups possibles au départ pour la machine sont de prendre 1, 2 ou 3 allumettes, s&#39;il en reste au moins 3. . S&#39;il n&#39;en reste que 2, elle peut en prendre 1 ou 2, et s&#39;il n&#39;en reste qu&#39;une, la machine la prend. . On modélise la situation par un tableau comportant la liste des coups possibles dans chaque cas : . coups_possibles = [[1], [1, 2]] + [[1,2,3] for i in range(NB_ALLUMETTES - 2)] où NB_ALLUMETTES est le nombre initial d&#39;allumettes, ici 8. . Lorsqu&#39;elle doit jouer, la machine choisit au hasard l&#39;un des coups possibles pour le nombre d&#39;allumettes restant. . Si aucun coup n&#39;est disponible, elle abandonne la partie qu&#39;elle considère comme perdue. . En fin de partie, si la machine a perdu, elle supprime de la liste des coups possibles le dernier coup réalisé. . def jouer_machine(nb_allumettes): &#39;&#39;&#39;- prend en paramètre le nombre d&#39;allumettes restant à jouer - renvoie le nombre d&#39;allumettes prises lors du coup joué par la machine et un booléen indiquant si ce coup a conduit à la perte de la partie pour la machine&#39;&#39;&#39; perdu = False if coups_possibles[nb_allumettes - 1] != []: coup_joue = choice(coups_possibles[nb_allumettes - 1]) else : perdu = True coup_joue = 0 return (coup_joue, perdu) . Jeu de l&#39;adversaire: . L&#39;adversaire adopte une stratégie élémentaire : . S&#39;il reste au plus 3 allumettes, il les prend toutes -- et la partie est perdue pour la machine ; | sinon, il choisit aléatoirement, entre 1 et 3, le nombre d&#39;allumettes à prendre. | . def jouer_adversaire(nb_allumettes): &#39;&#39;&#39;- prend en paramètre le nombre d&#39;allumettes restant à jouer - renvoie le nombre d&#39;allumettes prises lors du coup joué par l&#39;adversaire et un booléen indiquant si ce coup a conduit à la perte de la partie pour la machine&#39;&#39;&#39; perdu = False if nb_allumettes &lt; 4: coup_joue = nb_allumettes perdu = True else : coup_joue = randint(1,3) return (coup_joue, perdu) . D&#233;roulement du jeu . NB_ALLUMETTES = 8 . def jouer_partie(n): &#39;&#39;&#39; simule le déroulement de n parties successives, en faisant toujours commencer l&#39;adversaire de la machine et renvoie la liste des numéros des parties perdues&#39;&#39;&#39; parties_perdues = [] for i in range(n): perdu = False # perdu prend la valeur True lorsque la machine perd la partie allumettes = [NB_ALLUMETTES] # contient les valeurs successives au # cours d&#39;une partie du nombre d&#39;allumettes restantes while not perdu and allumettes[-1] &gt; 0 : #l&#39;adversaire joue nb_allumettes, perdu = jouer_adversaire(allumettes[-1]) allumettes.append(allumettes[-1] - nb_allumettes) if perdu : # le dernier coup de la machine a permis à l&#39;adversaire de # gagner : on supprime le coup correspondant de la # liste des coups possibles coups_possibles[allumettes[-3] - 1].remove(allumettes[-3] - allumettes[-2]) else : # la machine joue nb_allumettes, perdu = jouer_machine(allumettes[-1]) allumettes.append(allumettes[-1] - nb_allumettes) if perdu : #le précédent coup de la machine a conduit à sa défaite : # on supprime le coup correspondant de la liste des coups possibles coups_possibles[allumettes[-4] - 1].remove(allumettes[-4] - allumettes[-3]) if perdu : parties_perdues.append(i) return (parties_perdues) . coups_possibles = [[1], [1, 2]] + [[1,2,3] for i in range(NB_ALLUMETTES - 2)] n = 200 parties_perdues = jouer_partie(n) print(&quot;parties perdues : &quot;,len(parties_perdues), parties_perdues) . parties perdues : 12 [0, 1, 3, 6, 7, 10, 11, 25, 29, 36, 47, 64] . def representation_graphique(n): liste_resultats=[&quot;perdu&quot; if i in parties_perdues else &quot;gagné&quot; for i in range(n)] plt.scatter(list(range(n)),liste_resultats, s = 8, c = &#39;r&#39;) plt.title(&#39;Issue de chaque partie&#39;) plt.xlabel(&#39;numéro de partie jouée&#39;) plt.ylabel(&#39;issue&#39;) plt.show() . representation_graphique(n) . coups_possibles . [[1], [2], [3], [], [1], [2], [3], [1, 2, 3]] . Sources : . Quand une machine apprend à jouer au jeu de Nim (Marie Duflot), (CC BY SA) | .",
            "url": "https://nweibel.github.io/calepyns/jupyter/jeu/2020/07/31/jeu_de_nim.html",
            "relUrl": "/jupyter/jeu/2020/07/31/jeu_de_nim.html",
            "date": " • Jul 31, 2020"
        }
        
    
  
    
        ,"post2": {
            "title": "Ici ou là",
            "content": ". Note: Consulter le notebook complet (avec les cartes) sur Jupyter nbviewer. . L&#39;objectif est de représenter sur une carte géographique la localisation de communes dont le nom respecte certains critères, comme le fait de commencer ou terminer par certaines chaînes de caractères. . import csv import folium . with open(&#39;villes_france.csv&#39;,&#39;r&#39;, encoding =&#39;utf-8&#39;) as fichier: lecteur = csv.DictReader(fichier, delimiter=&#39;;&#39;) donnees = [dict(ligne) for ligne in lecteur] . #formatage des départements, CP et code_insee for commune in donnees: if len(commune[&#39;dept&#39;])==1: commune[&#39;dept&#39;] = &#39;0&#39;+ commune[&#39;dept&#39;] if len(commune[&#39;CP&#39;])==4: commune[&#39;CP&#39;] = &#39;0&#39;+ commune[&#39;CP&#39;] if len(commune[&#39;Code_insee&#39;])==4: commune[&#39;Code_insee&#39;] = &#39;0&#39;+ commune[&#39;Code_insee&#39;] . #aperçu des données donnees[0] . {&#39;nb&#39;: &#39;1&#39;, &#39;dept&#39;: &#39;01&#39;, &#39;COMMUNE&#39;: &#39;OZAN&#39;, &#39;Commune&#39;: &#39;Ozan&#39;, &#39;CP&#39;: &#39;01190&#39;, &#39;Code_insee&#39;: &#39;01284&#39;, &#39;longitude&#39;: &#39;4.91667&#39;, &#39;latitude&#39;: &#39;46.3833&#39;} . Localisation de quelques suffixes ou terminaisons des noms de communes . carte = folium.Map(location = [47,2], zoom_start = 6) for commune in donnees: couleur = &#39;&#39; if commune[&#39;COMMUNE&#39;].endswith(&#39;VILLE&#39;): couleur = &#39;ForestGreen&#39; elif commune[&#39;COMMUNE&#39;].endswith(&#39;BOURG&#39;): couleur = &#39;orange&#39; elif commune[&#39;COMMUNE&#39;].endswith(&#39;AC&#39;): couleur = &#39;crimson&#39; elif commune[&#39;COMMUNE&#39;].endswith(&#39;HEIM&#39;): couleur = &#39;navy&#39; elif commune[&#39;COMMUNE&#39;].endswith(&#39;COURT&#39;): couleur = &#39;Magenta&#39; elif commune[&#39;COMMUNE&#39;].endswith(&#39;MER&#39;): couleur = &#39;blue&#39; elif commune[&#39;COMMUNE&#39;].endswith(&#39;LOIRE&#39;): couleur = &#39;LightSeaGreen&#39; elif commune[&#39;COMMUNE&#39;].endswith(&#39;AY&#39;): couleur = &#39;Purple&#39; elif commune[&#39;COMMUNE&#39;].endswith(&#39;BAINS&#39;): couleur = &#39;cyan&#39; elif commune[&#39;COMMUNE&#39;].endswith(&#39;HEM&#39;): couleur = &#39;tomato&#39; if couleur != &#39;&#39;: message = commune[&#39;Commune&#39;] + &#39; (&#39; + commune[&#39;dept&#39;] + &#39; )&#39; coordonnees = [float(commune[&#39;latitude&#39;]), float(commune[&#39;longitude&#39;])] folium.CircleMarker(location = coordonnees, radius = 1, #rayon du cercle color = couleur, tooltip = message ).add_to(carte) carte . Localisation de quelques d&#233;buts des noms de communes . carte2 = folium.Map(location = [47,2], zoom_start = 6) for commune in donnees: couleur = &#39;&#39; if commune[&#39;COMMUNE&#39;].startswith(&#39;PL&#39;): couleur = &#39;crimson&#39; elif commune[&#39;COMMUNE&#39;].startswith(&#39;CA&#39;): couleur = &#39;blue&#39; elif commune[&#39;COMMUNE&#39;].startswith(&#39;CH&#39;): couleur = &#39;green&#39; elif commune[&#39;COMMUNE&#39;].startswith(&#39;W&#39;): couleur = &#39;orange&#39; elif commune[&#39;COMMUNE&#39;].startswith(&#39;K&#39;): couleur = &#39;cyan&#39; if couleur != &#39;&#39;: message = commune[&#39;Commune&#39;] + &#39; (&#39; + commune[&#39;dept&#39;] + &#39; )&#39; coordonnees = [float(commune[&#39;latitude&#39;]), float(commune[&#39;longitude&#39;])] folium.CircleMarker(location = coordonnees, radius = 1, #rayon du cercle color = couleur, tooltip = message ).add_to(carte2) carte2 .",
            "url": "https://nweibel.github.io/calepyns/jupyter/folium/csv/2020/07/30/villes_en_france.html",
            "relUrl": "/jupyter/folium/csv/2020/07/30/villes_en_france.html",
            "date": " • Jul 30, 2020"
        }
        
    
  
    
        ,"post3": {
            "title": "Fastpages Notebook Blog Post",
            "content": "About . This notebook is a demonstration of some of capabilities of fastpages with notebooks. . With fastpages you can save your jupyter notebooks into the _notebooks folder at the root of your repository, and they will be automatically be converted to Jekyll compliant blog posts! . Front Matter . The first cell in your Jupyter Notebook or markdown blog post contains front matter. Front matter is metadata that can turn on/off options in your Notebook. It is formatted like this: . # &quot;My Title&quot; &gt; &quot;Awesome summary&quot; - toc:true- branch: master- badges: true- comments: true - author: Hamel Husain &amp; Jeremy Howard - categories: [fastpages, jupyter] . Setting toc: true will automatically generate a table of contents | Setting badges: true will automatically include GitHub and Google Colab links to your notebook. | Setting comments: true will enable commenting on your blog post, powered by utterances. | . The title and description need to be enclosed in double quotes only if they include special characters such as a colon. More details and options for front matter can be viewed on the front matter section of the README. . Markdown Shortcuts . A #hide comment at the top of any code cell will hide both the input and output of that cell in your blog post. . A #hide_input comment at the top of any code cell will only hide the input of that cell. . The comment #hide_input was used to hide the code that produced this. . put a #collapse-hide flag at the top of any cell if you want to hide that cell by default, but give the reader the option to show it: . #collapse-hide import pandas as pd import altair as alt . . put a #collapse-show flag at the top of any cell if you want to show that cell by default, but give the reader the option to hide it: . #collapse-show cars = &#39;https://vega.github.io/vega-datasets/data/cars.json&#39; movies = &#39;https://vega.github.io/vega-datasets/data/movies.json&#39; sp500 = &#39;https://vega.github.io/vega-datasets/data/sp500.csv&#39; stocks = &#39;https://vega.github.io/vega-datasets/data/stocks.csv&#39; flights = &#39;https://vega.github.io/vega-datasets/data/flights-5k.json&#39; . . Interactive Charts With Altair . Charts made with Altair remain interactive. Example charts taken from this repo, specifically this notebook. . Example 1: DropDown . # single-value selection over [Major_Genre, MPAA_Rating] pairs # use specific hard-wired values as the initial selected values selection = alt.selection_single( name=&#39;Select&#39;, fields=[&#39;Major_Genre&#39;, &#39;MPAA_Rating&#39;], init={&#39;Major_Genre&#39;: &#39;Drama&#39;, &#39;MPAA_Rating&#39;: &#39;R&#39;}, bind={&#39;Major_Genre&#39;: alt.binding_select(options=genres), &#39;MPAA_Rating&#39;: alt.binding_radio(options=mpaa)} ) # scatter plot, modify opacity based on selection alt.Chart(movies).mark_circle().add_selection( selection ).encode( x=&#39;Rotten_Tomatoes_Rating:Q&#39;, y=&#39;IMDB_Rating:Q&#39;, tooltip=&#39;Title:N&#39;, opacity=alt.condition(selection, alt.value(0.75), alt.value(0.05)) ) . Example 2: Tooltips . alt.Chart(movies).mark_circle().add_selection( alt.selection_interval(bind=&#39;scales&#39;, encodings=[&#39;x&#39;]) ).encode( x=&#39;Rotten_Tomatoes_Rating:Q&#39;, y=alt.Y(&#39;IMDB_Rating:Q&#39;, axis=alt.Axis(minExtent=30)), # use min extent to stabilize axis title placement tooltip=[&#39;Title:N&#39;, &#39;Release_Date:N&#39;, &#39;IMDB_Rating:Q&#39;, &#39;Rotten_Tomatoes_Rating:Q&#39;] ).properties( width=600, height=400 ) . Example 3: More Tooltips . # select a point for which to provide details-on-demand label = alt.selection_single( encodings=[&#39;x&#39;], # limit selection to x-axis value on=&#39;mouseover&#39;, # select on mouseover events nearest=True, # select data point nearest the cursor empty=&#39;none&#39; # empty selection includes no data points ) # define our base line chart of stock prices base = alt.Chart().mark_line().encode( alt.X(&#39;date:T&#39;), alt.Y(&#39;price:Q&#39;, scale=alt.Scale(type=&#39;log&#39;)), alt.Color(&#39;symbol:N&#39;) ) alt.layer( base, # base line chart # add a rule mark to serve as a guide line alt.Chart().mark_rule(color=&#39;#aaa&#39;).encode( x=&#39;date:T&#39; ).transform_filter(label), # add circle marks for selected time points, hide unselected points base.mark_circle().encode( opacity=alt.condition(label, alt.value(1), alt.value(0)) ).add_selection(label), # add white stroked text to provide a legible background for labels base.mark_text(align=&#39;left&#39;, dx=5, dy=-5, stroke=&#39;white&#39;, strokeWidth=2).encode( text=&#39;price:Q&#39; ).transform_filter(label), # add text labels for stock prices base.mark_text(align=&#39;left&#39;, dx=5, dy=-5).encode( text=&#39;price:Q&#39; ).transform_filter(label), data=stocks ).properties( width=700, height=400 ) . Data Tables . You can display tables per the usual way in your blog: . movies = &#39;https://vega.github.io/vega-datasets/data/movies.json&#39; df = pd.read_json(movies) # display table with pandas df[[&#39;Title&#39;, &#39;Worldwide_Gross&#39;, &#39;Production_Budget&#39;, &#39;Distributor&#39;, &#39;MPAA_Rating&#39;, &#39;IMDB_Rating&#39;, &#39;Rotten_Tomatoes_Rating&#39;]].head() . Title Worldwide_Gross Production_Budget Distributor MPAA_Rating IMDB_Rating Rotten_Tomatoes_Rating . 0 The Land Girls | 146083.0 | 8000000.0 | Gramercy | R | 6.1 | NaN | . 1 First Love, Last Rites | 10876.0 | 300000.0 | Strand | R | 6.9 | NaN | . 2 I Married a Strange Person | 203134.0 | 250000.0 | Lionsgate | None | 6.8 | NaN | . 3 Let&#39;s Talk About Sex | 373615.0 | 300000.0 | Fine Line | None | NaN | 13.0 | . 4 Slam | 1087521.0 | 1000000.0 | Trimark | R | 3.4 | 62.0 | . Images . Local Images . You can reference local images and they will be copied and rendered on your blog automatically. You can include these with the following markdown syntax: . ![](my_icons/fastai_logo.png) . . Remote Images . Remote images can be included with the following markdown syntax: . ![](https://image.flaticon.com/icons/svg/36/36686.svg) . . Animated Gifs . Animated Gifs work, too! . ![](https://upload.wikimedia.org/wikipedia/commons/7/71/ChessPawnSpecialMoves.gif) . . Captions . You can include captions with markdown images like this: . ![](https://www.fast.ai/images/fastai_paper/show_batch.png &quot;Credit: https://www.fast.ai/2020/02/13/fastai-A-Layered-API-for-Deep-Learning/&quot;) . . Other Elements . GitHub Flavored Emojis . Typing I give this post two :+1:! will render this: . I give this post two :+1:! . Tweetcards . Typing &gt; twitter: https://twitter.com/jakevdp/status/1204765621767901185?s=20 will render this: Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 . Youtube Videos . Typing &gt; youtube: https://youtu.be/XfoYk_Z5AkI will render this: . Boxes / Callouts . Typing &gt; Warning: There will be no second warning! will render this: . Warning: There will be no second warning! . Typing &gt; Important: Pay attention! It&#39;s important. will render this: . Important: Pay attention! It&#8217;s important. . Typing &gt; Tip: This is my tip. will render this: . Tip: This is my tip. . Typing &gt; Note: Take note of this. will render this: . Note: Take note of this. . Typing &gt; Note: A doc link to [an example website: fast.ai](https://www.fast.ai/) should also work fine. will render in the docs: . Note: A doc link to an example website: fast.ai should also work fine. . Footnotes . You can have footnotes in notebooks, however the syntax is different compared to markdown documents. This guide provides more detail about this syntax, which looks like this: . For example, here is a footnote {% fn 1 %}. And another {% fn 2 %} {{ &#39;This is the footnote.&#39; | fndetail: 1 }} {{ &#39;This is the other footnote. You can even have a [link](www.github.com)!&#39; | fndetail: 2 }} . For example, here is a footnote 1. . And another 2 . 1. This is the footnote.↩ . 2. This is the other footnote. You can even have a link!↩ .",
            "url": "https://nweibel.github.io/calepyns/jupyter/2020/02/20/test.html",
            "relUrl": "/jupyter/2020/02/20/test.html",
            "date": " • Feb 20, 2020"
        }
        
    
  
    
        ,"post4": {
            "title": "An Example Markdown Post",
            "content": "Example Markdown Post . Basic setup . Jekyll requires blog post files to be named according to the following format: . YEAR-MONTH-DAY-filename.md . Where YEAR is a four-digit number, MONTH and DAY are both two-digit numbers, and filename is whatever file name you choose, to remind yourself what this post is about. .md is the file extension for markdown files. . The first line of the file should start with a single hash character, then a space, then your title. This is how you create a “level 1 heading” in markdown. Then you can create level 2, 3, etc headings as you wish but repeating the hash character, such as you see in the line ## File names above. . Basic formatting . You can use italics, bold, code font text, and create links. Here’s a footnote 1. Here’s a horizontal rule: . . Lists . Here’s a list: . item 1 | item 2 | . And a numbered list: . item 1 | item 2 | Boxes and stuff . This is a quotation . . You can include alert boxes …and… . . You can include info boxes Images . . Code . You can format text and code per usual . General preformatted text: . # Do a thing do_thing() . Python code and output: . # Prints &#39;2&#39; print(1+1) . 2 . Formatting text as shell commands: . echo &quot;hello world&quot; ./some_script.sh --option &quot;value&quot; wget https://example.com/cat_photo1.png . Formatting text as YAML: . key: value - another_key: &quot;another value&quot; . Tables . Column 1 Column 2 . A thing | Another thing | . Tweetcards . Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 Footnotes . This is the footnote. &#8617; . |",
            "url": "https://nweibel.github.io/calepyns/markdown/2020/01/14/test-markdown-post.html",
            "relUrl": "/markdown/2020/01/14/test-markdown-post.html",
            "date": " • Jan 14, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "À propos",
          "content": "Les notebooks présentés sur ce site sont réalisés pour l’enseignement, la formation ou par simple curiosité. Ils sont partagés selon les termes de la Licence Creative Commons Attribution - Partage dans les Mêmes Conditions 4.0. . Ces pages sont réalisées avec fastpages 1. . une plateforme de blog qui supporte nativement les notebooks Jupyter et d’autres formats. &#8617; . |",
          "url": "https://nweibel.github.io/calepyns/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://nweibel.github.io/calepyns/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}